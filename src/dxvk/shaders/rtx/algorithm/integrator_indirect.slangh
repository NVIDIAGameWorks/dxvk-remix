/*
* Copyright (c) 2022-2025, NVIDIA CORPORATION. All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a
* copy of this software and associated documentation files (the "Software"),
* to deal in the Software without restriction, including without limitation
* the rights to use, copy, modify, merge, publish, distribute, sublicense,
* and/or sell copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
#pragma once

#include "rtx/algorithm/path_state.slangh"
#include "rtx/utility/noise.slangh"
#include "rtx/utility/color.slangh"
#include "rtx/utility/packing.slangh"
#include "rtx/utility/debug_view_helpers.slangh"
#include "rtx/utility/gbuffer_helpers.slangh"
#include "rtx/concept/ray/ray.slangh"
#include "rtx/pass/instance_definitions.slangh"
#include "rtx/concept/surface/surface.slangh"
#include "rtx/algorithm/integrator.slangh"
#include "rtx/concept/surface_material/opaque_surface_material_interaction.slangh"
#include "rtx/pass/nrc/nrc_integrator_utilities.slangh"

// Input specular signal of low roughness material into restir gi
static const uint kRestirGIAcceptLowRoughnessInput = false;

// Integrate Helper Functions

PathState pathStateCreateEmpty(GeometryFlags geometryFlags)
{
  PathState pathState;

  // Note: Primary linear roughness, origin, cone radius, medium material index, inside medium flag and
  // direction assumed to be set by primary vertex intergation.

  pathState.bounceIteration = uint8_t(1);
  pathState.coneSpreadAngle = cb.screenSpacePixelSpreadHalfAngle;

  pathState.radiance = vec3(0.0f, 0.0f, 0.0f);
  pathState.throughput = f16vec3(1.h);
  pathState.firstBounceHitDistance = kEmptyPixelHitDistance;
  pathState.mediumMaterialIndex = BINDING_INDEX_INVALID;
  
  pathState.continueResolving = true;
  pathState.continuePath = true;
  pathState.insideMedium = false;
  pathState.decalEncountered = false;

  pathState.portalSpace = geometryFlags.portalSpace;
  pathState.indirectLightPortalID = RESTIR_GI_INVALID_INDIRECT_LIGHT_PORTAL_ID;
  pathState.restirGiHasFoundRoughSurface = false;
  pathState.restirGiHasHitGeometry = false;
  pathState.restirGiHasHitOpaque = false;
  pathState.segmentHitDistance = 0.0;

  pathState.rayMask = OBJECT_MASK_ALL | (geometryFlags.objectMask & OBJECT_MASK_ALL_DYNAMIC);

  if (geometryFlags.isViewModel)
  {
    updateRayMaskForRayOriginFromViewModelSurface(pathState.rayMask, pathState.portalSpace);
  }

  return pathState;
}

// Helper function to accumulate attenuation or other throughputs into the Path State throughput.
void accumulateThroughput(inout PathState pathState, vec3 throughput)
{
  pathState.throughput *= throughput;
}

// Overload for accumulating throughput for single-channel values.
void accumulateThroughput(inout PathState pathState, float throughput)
{
  pathState.throughput *= throughput;
}

// Helper function to accumulate radiance the Path State.
void accumulateRadiance(inout vec3 accumulatedRadiance, PathState pathState, vec3 radiance)
{
  accumulatedRadiance += pathState.throughput * radiance;
}

// Overload for simpler path state usage when accumulating radiance.
void accumulateRadiance(inout PathState pathState, vec3 radiance)
{
  accumulateRadiance(pathState.radiance, pathState, radiance);
}

// Calculate a point's screen space position, if it's outside the screen, move it to screen boundary.
// Return if the point is inside the screen.
bool calculateScreenBoundedPixelCoordinate(mat4 transformMatrix, vec3 position, inout ivec2 pixelCoordinate)
{
  vec4 ndc = mul(transformMatrix, vec4(position, 1.0f));
  ndc.xyz /= ndc.w;

  // Note: NDC x/y coordinates are valid from [-1, 1], whereas the NDC z (depth) is valid from [0, 1]
  bool isInsideScreen = all((ndc.xyz <= vec3(1.0f, 1.0f, 1.0f)) && (ndc.xyz >= vec3(-1.0f, -1.0f, 0.0f)));
  if (!isInsideScreen)
  {
    ndc.xy *= ndc.w < 0 ? -1 : 1;
    vec2 absXY = abs(ndc.xy);
    ndc.xy /= max(absXY.x, absXY.y);
  }

  pixelCoordinate = cameraNDCToPixelCoordinate(cb.camera, ndc.xy);

  return isInsideScreen;
}

uint2 jitterBoundaryPixels(uint2 pixelCoordinate, uint2 jitterOffset)
{
  const uint2 padding = uint2(16, 8);
  jitterOffset = (jitterOffset + cb.frameIdx) & (padding-1);
  jitterOffset = reversebits(jitterOffset) >> uint2(28,29);
  return clamp(pixelCoordinate, 0, cb.camera.resolution - padding) + jitterOffset;
}

bool sampleLightNeeCache(inout RAB_RandomSamplerState rtxdiRNG, inout RNG randomState, uint16_t neeCellOffset,
  SurfaceInteraction surfaceInteraction,
  OpaqueSurfaceMaterialInteraction opaqueSurfaceMaterialInteraction,
  f16vec3 viewDirection,
  out LightSample lightSample,
  out float invSelectionPdf,
  out uint16_t lightIdx)
{
  lightSample = {};

  NEECell cell = NEECache.getCell(neeCellOffset);

  const bool isThinOpaqueSubsurface = isThinOpaqueSubsurfaceMaterial(opaqueSurfaceMaterialInteraction);

  // Note: We are NOT taking transmission into consideration, because calculating probability of transmission has some costs.
  //       Also, it's an approximate importance sample and does not need to be exact, so we just skip the calculation here for better performance.
  float16_t specularRatio = calcBt709Luminance(opaqueSurfaceMaterialInteraction.baseReflectivity)
    / calcBt709Luminance(opaqueSurfaceMaterialInteraction.albedo + opaqueSurfaceMaterialInteraction.baseReflectivity);
  vec2 uniformRandomNumber = vec2(getNextSampleBlueNoise(randomState), getNextSampleBlueNoise(randomState));

  cell.sampleLightCandidate(rtxdiRNG, uniformRandomNumber,
    surfaceInteraction.position, viewDirection,
    opaqueSurfaceMaterialInteraction.shadingNormal, specularRatio, opaqueSurfaceMaterialInteraction.isotropicRoughness, isThinOpaqueSubsurface, lightIdx, invSelectionPdf);

  if (invSelectionPdf > 0)
  {
    MemoryPolymorphicLight memoryPolymorphicLight = lights[lightIdx];
    float2 sampleCoordinates0 = float2(getNextSampleBlueNoise(randomState), getNextSampleBlueNoise(randomState));
    lightSample = memoryPolymorphicLightSampleArea(memoryPolymorphicLight, sampleCoordinates0, surfaceInteraction);
    return true;
  }
  
  return false;
}

bool useNeeCacheOnThisBounce(uint bounce, bool enableNeeCacheAfterFirstBounce)
{
  return  (bounce == 1 && cb.neeCacheArgs.enableOnFirstBounce) ||
          (bounce >  1 && cb.neeCacheArgs.enableModeAfterFirstBounce != NeeEnableMode::None && enableNeeCacheAfterFirstBounce);
}

NrcProgressState updateNrcOnHit(
  inout PathState pathState,
  SurfaceInteraction surfaceInteraction,
  PolymorphicSurfaceMaterialInteraction polymorphicSurfaceMaterialInteraction)
{
  NrcProgressState nrcProgressState = NrcProgressState::Continue;

#if ENABLE_NRC

  const f16vec3 prevThroughput = pathState.throughput;

  nrcProgressState = Nrc::updateNrcOnHit(pathState.pixelCoordinate, pathState.isNrcUpdate,
    surfaceInteraction, polymorphicSurfaceMaterialInteraction, -pathState.direction,
    pathState.bounceIteration, pathState.segmentHitDistance, false, cb.nrcArgs,
    pathState.throughput, pathState.radiance, pathState.nrcPathState);

  // Update the total throughput when NRC resets it
  if (pathState.isNrcUpdate && all(pathState.throughput == 1.h))
  {
    pathState.throughputFullPath *= prevThroughput;
  }

#else

  unused(pathState);

#endif

  return nrcProgressState;
}

// Integrate Path Vertex Functions

void integratePathVertex( 
  IndirectPathTextures indirectPathTextures, RayHitInfo rayHitInfo,
  inout PathState pathState)
{
  const bool separateUnorderedApproximations = pathState.getSeparateUnorderedApproximationsActive();

  // Setup resolve state

  // Note: Emissives are fine to approximate here (since lighting rarely matters on them), and non-emissive opacity particles should be
  // lit with the lighting approximation when particles will be hit in general (only when separate unordered approximations are enabled,
  // as on bounce counts higher than 1 all particles will be skipped).
  const uint8_t resolveMode =
    resolveModeRayPortalNotify |
    resolveModeEmissiveOpacityTransmissionApprox |
    (cb.enableTransmissionApproximationInIndirectRays ? resolveModeTranslucencyTransmissionApprox : 0) |
    resolveModeDecalMaterialBlending |
    (separateUnorderedApproximations ? resolveModeSeparateUnorderedApproximations : 0);
  f16vec3 radianceAttenuation = f16vec3(1.0f, 1.0f, 1.0f);
  vec3 emissiveRadiance = vec3(0);

  // Handle Unordered Resolving
  // Note: Done before resolveVertex so attenuation from unordered objects
  // between the origin and the hit point can be accumulated in advance.

  // Note: Only do unordered resolving when separate unordered approximations are desired for this bounce of the path.
  pathState.decalEncountered = false;
  
  uint4 decalMemory = 0;
  f16vec3 decalEmissiveRadiance = f16vec3(0);
  int unorderedSurfaceIndex = -1;  
  bool isNeeEnabledOnBounce = useNeeCacheOnThisBounce(pathState.bounceIteration, pathState.enableNeeCacheAfterFirstBounce);
  if (separateUnorderedApproximations)
  {
    Ray unorderedResolveRay;
    unorderedResolveRay.origin = pathState.origin;
    unorderedResolveRay.coneRadius = pathState.coneRadius;
    unorderedResolveRay.spreadAngle = float16_t(cb.screenSpacePixelSpreadHalfAngle);
    unorderedResolveRay.direction = pathState.direction;
    unorderedResolveRay.tMax = rayHitInfo.hasHit ? rayHitInfo.hitDistance * kUnorderedResolveRayLengthening : floatMax;

    uint numUnorderedInteractions = 0;
    uint8_t unorderedRayMask = OBJECT_MASK_UNORDERED_ALL_BLENDED
      | (cb.enableUnorderedEmissiveParticlesInIndirectRays ? OBJECT_MASK_UNORDERED_ALL_EMISSIVE : 0);
    unorderedRayMask = convertPrimaryRayMaskToUnordered(pathState.rayMask, unorderedRayMask);
    
    resolveVertexUnordered<RAY_FLAG_CULL_OPAQUE>(
      resolveMode, unorderedResolveRay,
      unorderedRayMask, pathState.portalSpace,
      /* useIntersectionBillboards = */ cb.enableBillboardOrientationCorrection,
      pathState.accumulatedHitDistance, pathState.getUnorderedApproximationSelectionProbability(),
      radianceAttenuation, emissiveRadiance,
      numUnorderedInteractions, 
      pathState.decalEncountered, decalMemory, decalEmissiveRadiance, unorderedSurfaceIndex);

    if ((cb.debugView == DEBUG_VIEW_SECONDARY_UNORDERED_INTERACTIONS 
         || cb.debugView == DEBUG_VIEW_SECONDARY_RAY_AND_UNORDERED_INTERACTIONS)
        && TRUE_OR_CHECK_WHEN_NRC_ENABLED(pathState.isNrcQuery))
    {
      accumulateInDebugViewAdd(pathState.pixelCoordinate, numUnorderedInteractions);
    }

    if (NEE_CACHE_ENABLE && cb.neeCacheArgs.enable && isNeeEnabledOnBounce && unorderedSurfaceIndex != -1)
    {
      // Insert new task
      NEECell cell = NEECache.getCell(pathState.neeCacheCellOffset);
      int prefixTask = NEECacheUtils.convertIDToPrefixSumID(unorderedSurfaceIndex, 0, PrimitiveIDPrefixSum);
      cell.insertSlotTask(prefixTask, emissiveRadiance * pathState.calculateFullThroughput(), false);
    }
  }

  // Invoke the Resolve Vertex function
  Ray ray;
  RayInteraction rayInteraction;
  Surface surface;
  SurfaceInteraction surfaceInteraction;
  PolymorphicSurfaceMaterialInteraction polymorphicSurfaceMaterialInteraction;
  bool isRaytracedRenderTarget = false;
  
  surfaceInteraction.position = pathState.origin;
  
  pathState.segmentHitDistance = 0;

  bool pomOpaqueSurfaceEncountered = false;
  bool isStochasticAlphaBlend = false; // note: not used here
  uint8_t firstRayPortal = invalidRayPortalIndex;

  resolveVertex<PathState>(
    resolveMode,
    rayHitInfo, pathState,
    ray, rayInteraction,
    surface, surfaceInteraction,
    polymorphicSurfaceMaterialInteraction,
    radianceAttenuation, emissiveRadiance,
    decalMemory, decalEmissiveRadiance, 
    pathState.coneSpreadAngle,
    isStochasticAlphaBlend, firstRayPortal,
    pomOpaqueSurfaceEncountered,
    isRaytracedRenderTarget);

  // We can encounter a POM surface during resolving (as it's a shared function).  But if POM is disabled in indirect cases
  //  we must also handle that case and ensure nothing tries to use POM elsewhere.
  pomOpaqueSurfaceEncountered = pomOpaqueSurfaceEncountered && cb.pomEnableIndirectLighting;
  
#if !ENABLE_NRC
  // Output ReSTIR GI geometry information

  if (cb.enableReSTIRGI && !pathState.restirGiHasHitGeometry)
  {
    if (pathState.continueResolving)
    {
      if (firstRayPortal != invalidRayPortalIndex)
      {
        pathState.indirectLightPortalID = firstRayPortal;
      }
    }
    else
    {
      vec3 hitPosition;
      f16vec3 hitNormal = f16vec3(0,0,0);
      if (rayInteractionHasHit(rayInteraction))
      {
        hitPosition = surfaceInteraction.position;
        hitNormal = surfaceInteraction.triangleNormal;

        // Only consider geometry from opaque surfaces.
        // Suppose an indirect ray goes through glass and then hits a bright opaque wall, the light is coming from the opaque wall,
        // not glass. Therefore we should record a sample on the wall instead of glass. 
        const uint materialType = polymorphicSurfaceMaterialInteractionGetTypeHelper(polymorphicSurfaceMaterialInteraction);
        pathState.restirGiHasHitOpaque = (materialType == surfaceMaterialTypeOpaque);
        pathState.restirGiHasHitGeometry = (materialType == surfaceMaterialTypeOpaque);
      }
      else
      {
        // When ray miss occurs, we assume the sample is on the sky dome with a large distance to the scene.
        const float skyDomeDistance = 1e5;
        hitPosition = pathState.origin + float3(pathState.direction) * skyDomeDistance;
        hitNormal = -pathState.direction;
      }
      ReSTIRGI_StoreHitGeometry(RestirGIHitGeometry, pathState.pixelCoordinate, hitPosition, hitNormal, pathState.indirectLightPortalID);
    }
  }
#endif  

  if (rayInteractionHasHit(rayInteraction))
  {
    pathState.accumulatedHitDistance += pathState.segmentHitDistance;

    if (pathState.bounceIteration == 1)
    {
      pathState.firstBounceHitDistance = float16_t(min(float16Max, pathState.segmentHitDistance));
    }
  }
  else if (!pathState.continueResolving)
  {
    // Apply sky radiance on miss
    // Note: True misses going out into infinity will have no hit in the ray interaction and the continue resolving flag set to false. This is in contrast to misses
    // which may require further resolving which may be needed in cases of skipping specific pieces of geometry while still wishing to continue traversal.

    float3 skyRadiance;
    if (cb.domeLightArgs.active)
    {
      skyRadiance = cb.domeLightArgs.radiance * sampleDomeLightTexture(LinearWrapSampler, pathState.direction, cb.domeLightArgs.textureIndex, cb.domeLightArgs.worldToLightTransform);
    }
    else
    {
      skyRadiance = cb.skyBrightness * SkyProbe.SampleLevel(pathState.direction, 0);
    }
    
    emissiveRadiance += skyRadiance * radianceAttenuation;
    
#if ENABLE_NRC
    Nrc::updateNrcOnMiss(
      pathState.pixelCoordinate, pathState.isNrcUpdate, pathState.nrcPathState, false);
#endif
  }
 
  // Update NRC on hit

  NrcProgressState nrcProgressState = NrcProgressState::Continue;
  
  if (ENABLE_NRC && rayInteractionHasHit(rayInteraction) && !pathState.continueResolving) 
  {  
    nrcProgressState = updateNrcOnHit(pathState, surfaceInteraction, polymorphicSurfaceMaterialInteraction);

    if (nrcProgressState == NrcProgressState::TerminateImmediately)
    {
      pathState.continuePath = false;
      return;
    }
  }

  // Handle emissive radiance and attenuation from the Resolve function

  // Note: When accumulating radiance/throughput from the resolve logic, emissive takes priority
  // over attenuation so that emissive surfaces do not attenuate themselves.
  float16_t oldLuminance = calcBt709Luminance(pathState.radiance);
  accumulateRadiance(pathState, emissiveRadiance);
  accumulateThroughput(pathState, radianceAttenuation);

  // Handle medium attenuation if needed
  // Note: This is done here to avoid needing to accumulate the total resolved hit distance. Slightly
  // more expensive in some cases than doing it after resolving is finished, but saves payload space.
  // Additionally this allows for proper handling of infinite attenuation when a miss happens.

  if (pathState.mediumMaterialIndex != BINDING_INDEX_INVALID)
  {
    const MemoryPolymorphicSurfaceMaterial memoryPolymorphicSurfaceMaterial = surfaceMaterials[pathState.mediumMaterialIndex];
    const TranslucentSurfaceMaterial translucentSurfaceMaterial = translucentSurfaceMaterialCreate(memoryPolymorphicSurfaceMaterial);

    // Calculate the volume transmittance

    f16vec3 volumeTransmittance;

    if (rayInteractionHasHit(rayInteraction))
    {
      volumeTransmittance = translucentSurfaceMaterialEvalVolumeTransmittance(
        translucentSurfaceMaterial, rayInteraction.hitDistance);
    }
    else
    {
      // Note: Assume infinite hit distance on miss. This wouldn't be true with things that have a practical tMax
      // value (such as NEE rays), but for the geometry resolver this is a fine assumption.
      volumeTransmittance = translucentSurfaceMaterialEvalInfiniteVolumeTransmittance(
        translucentSurfaceMaterial);
    }

    accumulateThroughput(pathState, volumeTransmittance);
  }

  // If the camera index changed then this ray passed through a render target. Cast a ray from the new camera.
  if (cb.enableRaytracedRenderTarget && isRaytracedRenderTarget && pathState.bounceIteration == 1)
  {
    Ray newRay = rayCreateRenderTarget(cb.renderTargetCamera, surfaceInteraction.textureCoordinates, ray);
    pathState.origin = newRay.origin;
    pathState.direction = newRay.direction;
    pathState.insideMedium = false;
    pathState.mediumMaterialIndex = BINDING_INDEX_INVALID;
    pathState.continuePath = true;
    
    if (cb.debugView == DEBUG_VIEW_RAYTRACED_RENDER_TARGET_INDIRECT
      && TRUE_OR_CHECK_WHEN_NRC_ENABLED(pathState.isNrcQuery))
    {
      storeInDebugView(pathState.pixelCoordinate, vec4(1.f));
    }
    return;
  }

  const uint materialType = polymorphicSurfaceMaterialInteractionGetTypeHelper(polymorphicSurfaceMaterialInteraction);

  // Add Emission
  vec3 emissiveLight = polymorphicSurfaceMaterialInteractionEvalEmissiveRadiance(polymorphicSurfaceMaterialInteraction);
  float lightSelectionPDF = 0.0;

#if (SURFACE_MATERIAL_RESOLVE_TYPE_ACTIVE_MASK & SURFACE_MATERIAL_RESOLVE_TYPE_RAY_PORTAL) != 0
  if (materialType == surfaceMaterialTypeOpaque || materialType == surfaceMaterialTypeTranslucent)
  {
#endif // SURFACE_MATERIAL_RESOLVE_TYPE_RAY_PORTAL

    if (NEE_CACHE_ENABLE && cb.neeCacheArgs.enable && isNeeEnabledOnBounce && any(emissiveLight > 0))
    {
      NEECell cell = NEECache.getCell(pathState.neeCacheCellOffset);

      // Insert new task
      bool shouldSampleObject = NEECacheUtils.shouldSampleObject(surface);
      int primitiveIndex = shouldSampleObject ? 0 : rayInteraction.primitiveIndex;
      int surfaceIndex = rayInteraction.surfaceIndex;
      int prefixTask = NEECacheUtils.convertIDToPrefixSumID(surfaceIndex, primitiveIndex, PrimitiveIDPrefixSum);
      cell.insertSlotTask(prefixTask, emissiveLight * pathState.calculateFullThroughput(), false);

      lightSelectionPDF = cell.searchCandidate(surfaceIndex, primitiveIndex);
      if (lightSelectionPDF > 0.0 && shouldSampleObject)
      {
        lightSelectionPDF /= NEECacheUtils.getSurfacePrimitiveCount(surfaceIndex, PrimitiveIDPrefixSum);
      }
    }

#if (SURFACE_MATERIAL_RESOLVE_TYPE_ACTIVE_MASK & SURFACE_MATERIAL_RESOLVE_TYPE_RAY_PORTAL) != 0
  }
#endif // SURFACE_MATERIAL_RESOLVE_TYPE_RAY_PORTAL

  // Check if resolving should continue, and if a surface was hit

  if (pathState.continueResolving)
  {
    return;
  }

  if (!rayInteractionHasHit(rayInteraction))
  {
    return;
  }

  // Add emissive light radiance
  {
    float misWeight = 1.0;
    if (lightSelectionPDF > 0.0)
    {
      misWeight = NEECacheUtils.calculateBRDFSampleMISWeight(surfaceInteraction, pathState.direction, pathState.segmentHitDistance, lightSelectionPDF, pathState.solidAnglePdf);
    }

    const vec3 emissiveLightRadiance = emissiveLight * misWeight;
    accumulateRadiance(pathState, emissiveLightRadiance);
  }

// We don't need to sample lights or surface rays in the portal closest hit shader
#if (SURFACE_MATERIAL_RESOLVE_TYPE_ACTIVE_MASK & SURFACE_MATERIAL_RESOLVE_TYPE_RAY_PORTAL) != 0
  if (materialType == surfaceMaterialTypeOpaque || materialType == surfaceMaterialTypeTranslucent)
  {
#endif // SURFACE_MATERIAL_RESOLVE_TYPE_RAY_PORTAL

    // Construct RNG
    RNG randomState = createRNG(pathState.pixelCoordinate, cb.frameIdx, pathState.calculateRNGOffset(kRNGOffsetSampleClosestHitShader));
    
    float16_t restirHitT = float16_t(kMissHitDistance);
    updateReSTIRGIHitDistance(oldLuminance, calcBt709Luminance(pathState.radiance), restirHitT, pathState.accumulatedHitDistance);
    
    const bool oldInsideMedium = pathState.insideMedium;
    vec3 continuationThroughput = f16vec3(1.0);
    uint8_t continuationLobe = 0;
    f16vec3 incomingDirection = pathState.direction;
    {
      // Sample a new direction
      float16_t sampledLobePdf, solidAnglePdf;

      // Note: If this sample is invalid the throughput and solid angle pdf will be set to 0.
      const Ray sampledRay = sampleDirection(
        randomState, pathState.insideMedium, continuationThroughput,
        ray, rayInteraction, surfaceInteraction,
        polymorphicSurfaceMaterialInteraction,
        continuationLobe, sampledLobePdf, solidAnglePdf,
        false);

      // Stop recording hit geometry when translucent material emitting a scattering ray
      if (materialType == surfaceMaterialTypeTranslucent && dot(sampledRay.direction, pathState.direction) < 0.9)
      {
        pathState.restirGiHasHitGeometry = true;
      }

      // Set the ray into the path vertex state
      pathState.origin = sampledRay.origin;
      pathState.coneRadius = sampledRay.coneRadius;
      pathState.direction = sampledRay.direction;
      pathState.solidAnglePdf = solidAnglePdf;
    }
    
    // Set the material medium index if a medium was entered or exited
    
    evalMediumChange(
      oldInsideMedium, pathState.insideMedium,
      polymorphicSurfaceMaterialInteraction, pathState.mediumMaterialIndex);
    
    // Get Opaque material information for future reference
    
    const bool isOpaqueMaterial = materialType == surfaceMaterialTypeOpaque;
    const OpaqueSurfaceMaterialInteraction opaqueSurfaceMaterialInteraction = opaqueSurfaceMaterialInteractionCreate(polymorphicSurfaceMaterialInteraction);
    // polymorphicSurfaceMaterialInteraction is no longer live since this point.
    
    // Perform NEE
    
    if (isOpaqueMaterial)
    {
      LightSample lightSample;
      float invSelectionPdf;
      bool lightSampleValid = false;
      bool isWithinGbuffer = false;
      // Only steal rtxdi sample on rough surfaces with weak specular lobe, otherwise specular highlight will get lost.
      // The value is based on experiment.
      const float16_t baseReflectivityFactor = 3.0f;
      uint16_t lightIdx = kInvalidLightIdx;
      if (cb.enableRtxdi && cb.enableRtxdiSampleStealing &&
        calcBt709Luminance(opaqueSurfaceMaterialInteraction.baseReflectivity) < baseReflectivityFactor * opaqueSurfaceMaterialInteraction.isotropicRoughness) 
      {
        // Perform some safety checks, and if lucky, steal some high quality samples from RTX-DI reservoirs
        ivec2 pixelCoordinate;
        isWithinGbuffer = calculateScreenBoundedPixelCoordinate(
          cb.camera.worldToProjectionJittered,
          surfaceInteraction.position, pixelCoordinate);
    
        if (cb.enableRtxdiStealBoundaryPixelSamplesWhenOutsideOfScreen && !isWithinGbuffer)
        {
          pixelCoordinate = jitterBoundaryPixels(pixelCoordinate, pathState.pixelCoordinate);
          isWithinGbuffer = true;
        }
    
        if (isWithinGbuffer)
        {
          MinimalSurfaceInteraction gbuffer = minimalSurfaceInteractionReadFromGBuffer(pixelCoordinate, indirectPathTextures.PrimaryWorldPositionWorldTriangleNormal);
          float3 relativePosition = gbuffer.position - surfaceInteraction.position;
          float relativeLength = length(relativePosition);
          float cameraDistance = length(surfaceInteraction.position - cameraGetWorldPosition(cb.camera));
          const float planeTolerance = 0.1;
          const float distanceTolerance = 0.01;
          isWithinGbuffer = dot(surfaceInteraction.interpolatedNormal, gbuffer.triangleNormal) > 0.8f &&   // sane normal difference?
                            gbuffer.isValid && // was this pixel valid
                            (relativeLength < cameraDistance * distanceTolerance ||
                             abs(dot(relativePosition, surfaceInteraction.interpolatedNormal)) < planeTolerance * relativeLength);
        }
    
        if (isWithinGbuffer)
        {
          uint8_t sampledTransportPortalIndex = invalidRayPortalIndex;
    
          // Select and sample a light for NEE via RTXDI
    
          lightSampleValid = sampleLightRTXDI(
            pixelCoordinate,
            surfaceInteraction,
            lightSample, invSelectionPdf, sampledTransportPortalIndex, lightIdx);
        }
      }

      RAB_RandomSamplerState rtxdiRNG;
      if (NEE_CACHE_ENABLE && cb.neeCacheArgs.enable)
      {
        rtxdiRNG = RAB_InitRandomSampler(pathState.pixelCoordinate, cb.frameIdx, pathState.bounceIteration);
        uint jitter = sampleUniformIntRng(rtxdiRNG);
        pathState.neeCacheCellOffset = NEECache.pointToOffset(surfaceInteraction.position, surfaceInteraction.triangleNormal, jitter);
      }

      if (!isWithinGbuffer)
      {
        if (NEE_CACHE_ENABLE && cb.neeCacheArgs.enable && cb.neeCacheArgs.enableAnalyticalLight)
        {
          lightSampleValid = sampleLightNeeCache(rtxdiRNG, randomState, pathState.neeCacheCellOffset,
            surfaceInteraction, opaqueSurfaceMaterialInteraction, rayInteraction.viewDirection,
            lightSample, invSelectionPdf, lightIdx);
        }
        else
        {
          // Select and sample a light for NEE via RIS
          lightSampleValid = sampleLightRIS(
            randomState,
            surfaceInteraction, opaqueSurfaceMaterialInteraction, rayInteraction.viewDirection,
            lightSample, invSelectionPdf, lightIdx);
        }
      }


      lightSample.solidAnglePdf = invSelectionPdf > 0 ? lightSample.solidAnglePdf / invSelectionPdf : 0.0;
      vec3 diffuseLight, specularLight;
      const bool isDiffusionProfileSss = (cb.sssArgs.enableDiffusionProfile && isSubsurfaceDiffusionProfileMaterial(opaqueSurfaceMaterialInteraction));
      evaluateUnshadowedLight(lightSample, opaqueSurfaceMaterialInteraction, rayInteraction, normalize(lightSample.position - surfaceInteraction.position), diffuseLight, specularLight);

      uint lightTask = lightIdx;
      if (NEE_CACHE_ENABLE && cb.neeCacheArgs.enable && 
          cb.neeCacheArgs.enableModeAfterFirstBounce != NeeEnableMode::None && 
          pathState.enableNeeCacheAfterFirstBounce)
      {
        NEECell cell = NEECache.getCell(pathState.neeCacheCellOffset);
        if (cell.isValid() && cell.getCandidateCount() > 0)
        {
          float randomNumber = RAB_GetNextRandom(rtxdiRNG);
          uint triangleID;
          LightSample lightSampleTriangle = cell.getCachedLightSample(randomNumber, surfaceInteraction.position, rayInteraction.coneRadius, pathState.coneSpreadAngle, triangleID);
          
          // Calculate cached triangle NEE sample's MIS light contribution
          vec3 diffuseLightTriangle, specularLightTriangle;
          f16vec3 inputDirection = normalize(lightSampleTriangle.position - surfaceInteraction.position);
          evaluateUnshadowedLight(lightSampleTriangle, opaqueSurfaceMaterialInteraction, rayInteraction, inputDirection, diffuseLightTriangle, specularLightTriangle);
          vec2 misWeight = NEECacheUtils.calculateLightSampleMISWeight(opaqueSurfaceMaterialInteraction, inputDirection, rayInteraction.viewDirection, lightSampleTriangle.solidAnglePdf);
          diffuseLightTriangle *= misWeight.x;
          specularLightTriangle *= misWeight.y;
  
          // Use RIS to choose between the light NEE sample and the cached triangle NEE sample
          float weightLight = lightSampleValid && lightSample.solidAnglePdf > 0 ? calcBt709Luminance(diffuseLight + specularLight) / lightSample.solidAnglePdf : 0;
          float weightTriangle = lightSampleTriangle.solidAnglePdf > 0 ? calcBt709Luminance(diffuseLightTriangle + specularLightTriangle) / lightSampleTriangle.solidAnglePdf : 0;
          float r = RAB_GetNextRandom(rtxdiRNG);
          if (r * (weightLight + weightTriangle) > weightLight)
          {
            lightIdx = kInvalidLightIdx;
            lightTask = triangleID;
            lightSample = lightSampleTriangle;
            diffuseLight = diffuseLightTriangle;
            specularLight = specularLightTriangle;
          }
  
          // Finalize the chosen sample
          float targetPdf = calcBt709Luminance(diffuseLight + specularLight);
          lightSample.solidAnglePdf = targetPdf / (weightLight + weightTriangle);
          lightSampleValid = true;
        }
      }
    
      if (lightSampleValid)
      {
        const bool isViewModel = pathState.rayMask & OBJECT_MASK_ALL_VIEWMODEL;
        
        // Todo: Ray Portal transport sampling in the future.
        evalNEESecondary(
          lightSample, invalidRayPortalIndex, pathState.portalSpace, pathState.rayMask, pomOpaqueSurfaceEncountered,
          isViewModel, ray, rayInteraction, surfaceInteraction, opaqueSurfaceMaterialInteraction,
          diffuseLight, specularLight, rayInteraction.surfaceIndex, surfaceInteraction.textureCoordinates);

        // Create a NEE Cache task for lights with non-zero contributions.
        // Both light task and emissive triangle task are using the same buffer, skip some pixels so that triangle tasks on them won't be overwritten by light tasks.
        const vec3 neeLight = diffuseLight + specularLight;

        // WAR for REMIX-3705 producing NaNs here
        if (isValidValue(neeLight))
        {
          if (NEE_CACHE_ENABLE && cb.neeCacheArgs.enable && 
              any(neeLight > 0) && 
              all((pathState.pixelCoordinate & 0x3) != 1))
          {
            NEECell cell = NEECache.getCell(pathState.neeCacheCellOffset);
            cell.insertSlotTask(lightTask, neeLight, lightIdx != kInvalidLightIdx);
          }
      
          float16_t specularPortion = calcBt709Luminance(specularLight) / calcBt709Luminance(neeLight);
      
          accumulateRadiance(pathState, neeLight);
      
          float hitT = pathState.accumulatedHitDistance;
          if (opaqueSurfaceMaterialInteraction.isotropicRoughness <= cb.reSTIRGIVirtualSampleRoughnessThreshold
            && specularPortion >= cb.reSTIRGIVirtualSampleSpecularThreshold)
          {
            hitT += length(lightSample.position - surfaceInteraction.position);
          }
      
          updateReSTIRGIHitDistance(oldLuminance, calcBt709Luminance(pathState.radiance), restirHitT, min(hitT, float16Max));
        }
      }
    }

    // Terminate the path if NRC requested it
    if (ENABLE_NRC && nrcProgressState == NrcProgressState::TerminateAfterDirectLighting)
    {
      pathState.continuePath = false;
      return;
    }
    
    // Check for path termination
    // Note: Bounce iteration refers to the index of the current vertex in the path,
    // 0 = Primary Hit, 1 = 1st Indirect Hit (1 bounce), etc. The decision to terminate here
    // represents if the path should terminate at this current bounce iteration and not
    // cast another ray.
    pathState.continuePath = true;
    
    if (pathState.bounceIteration >= pathState.pathMaxBounces)
    {
      // Note: Don't continue paths past the maximum number of requested bounces.
      pathState.continuePath = false;
    }
    else if (all(continuationThroughput == vec3(0.0f)))
    {
      // Note: Don't continue paths with zero continuation throughput from the sampled direction, be it as a
      // signal for invalid direction samples or simply having all the energy reduced to 0 by albedo for instance.
      // This is done as while russian roulette will typically handle this properly (a throughput of 0 means a
      // probability of 0), the current implementation allows for non-throughput based russian roulettes, or even
      // for it to be disabled entierly, which would allow potentially invalid direction samples to continue and
      // generate issues for subsequent bounces. As such this case needs to be handled explicitly. In the future
      // it may even be a better idea to return a boolean from the material's direction sampling function to
      // avoid this potential mistake by forcing callers to consider the boolean separately rather than encoding
      // it in the throughput.
      pathState.continuePath = false;
    }
    else if (pathState.calculateUseRussianRoulette())
    {
      // Russian Roulette
      // Note: This logic will conditionally terminate paths based on the effective throughput, allowing for
      // paths which contribute little to the final image to be shorter while paths which are more important
      // are allowed to be longer.

      const float continueProbability = calculateRussianRouletteContinueProbability(
        pathState,
        isOpaqueMaterial,
        continuationLobe != opaqueLobeTypeDiffuseReflection,
        continuationThroughput,
        opaqueSurfaceMaterialInteraction.isotropicRoughness,
        rayInteraction.hitDistance / pathState.accumulatedHitDistance);
    
      const float continueSample = getNextSampleBlueNoise(randomState);
      // Note: <= used to ensure path never continues if the probability is 0 (and to avoid NaNs in the
      // throughput when the probability is divided into it).
      const bool terminate = continueProbability <= continueSample;

      if (terminate)
      {    
        pathState.continuePath = false;
      } 
      else
      {
        // Note: Factor the probability of continuing the path into the throughput. This causes odd brightness
        // in denoising when the continue probability is very low, but this math has been validated to be
        // correct as far as I can tell.
        continuationThroughput /= continueProbability;
      }
    }

#if !ENABLE_NRC    
    // Steal samples from restir gi
    if (cb.enableReSTIRGI
      && cb.enableReSTIRGISampleStealing > 0
      && isOpaqueMaterial)
    {
      // Perform some safety checks, and if lucky, steal some high quality samples from ReSTIR GI reservoirs
      ivec2 pixelCoordinate;
      bool isWithinGbuffer = calculateScreenBoundedPixelCoordinate(
        cb.camera.prevWorldToProjectionJittered,
        surfaceInteraction.position, pixelCoordinate);

      if (cb.reSTIRGISampleStealingJitter > 0)
      {
        vec2 jitterUV = vec2(getNextSampleBlueNoise(randomState), getNextSampleBlueNoise(randomState)) * 2.0 - 1.0;
        pixelCoordinate += int2(jitterUV * cb.reSTIRGISampleStealingJitter);
      }
    
      if (cb.enableReSTIRGIStealBoundaryPixelSamplesWhenOutsideOfScreen && !isWithinGbuffer)
      {
        pixelCoordinate = jitterBoundaryPixels(pixelCoordinate, pathState.pixelCoordinate);
        isWithinGbuffer = true;
      }
    
      if (isWithinGbuffer)
      {
        const MinimalSurfaceInteraction prevSurfaceInteraction = minimalSurfaceInteractionReadFromGBuffer(
          pixelCoordinate, PreviousWorldPosition_WorldTriangleNormal);
    
        float prevHitDistance = length(prevSurfaceInteraction.position - cameraGetWorldPosition(cb.camera));
        float3 relativePosition = prevSurfaceInteraction.position - surfaceInteraction.position;
        float relativeLength = length(relativePosition);
        const float planeTolerance = 0.1;
        const float distanceTolerance = 0.05;
    
        isWithinGbuffer =
          dot(surfaceInteraction.triangleNormal, prevSurfaceInteraction.triangleNormal) > 0.8f &&
          prevSurfaceInteraction.isValid &&
          (relativeLength < prevHitDistance * distanceTolerance ||
            abs(dot(prevSurfaceInteraction.triangleNormal, relativePosition)) < relativeLength * planeTolerance);
      }

      if (cb.enableReSTIRGILightingValidation > 0 && isWithinGbuffer)
      {
        ivec2 pixelCoordinateCurrentFrame;
        bool isWithinGbufferCurrentFrame = calculateScreenBoundedPixelCoordinate(
          cb.camera.worldToProjectionJittered,
          surfaceInteraction.position, pixelCoordinateCurrentFrame);

        if (isWithinGbufferCurrentFrame)
        {
          vec2 gradient = RtxdiGradients[uint3(pixelCoordinate / RTXDI_GRAD_FACTOR, 0)];
          if (gradient.x > cb.reSTIRGISampleValidationThreshold)
          {
            isWithinGbuffer = false;
          }
        }
      }
    
      vec3 indirectLight = vec3(0);
      if (isWithinGbuffer && opaqueSurfaceMaterialInteraction.opacity == float16_t(1))
      {
        if (cb.enableReSTIRGISampleStealing == 2)
        {
          if (cb.isLastCompositeOutputValid)
          {
            vec4 lastColor = LastComposite[pixelCoordinate];
            accumulateRadiance(pathState, lastColor.xyz * opaqueSurfaceMaterialInteraction.albedo + lastColor.w * opaqueSurfaceMaterialInteraction.baseReflectivity);
          }
        }
        else
        {
          ReSTIRGI_Reservoir spatialReservoir = RAB_LoadGIReservoir(pixelCoordinate, ReSTIRGI_GetSpatialOutputPage());
            
          if (!spatialReservoir.getFlag(RESTIR_GI_FLAG_OCCLUDED_SAMPLE))
          {
            MinimalRayInteraction minimalRayInteraction2;
            minimalRayInteraction2.coneRadius = 0.0;
            minimalRayInteraction2.viewDirection = -incomingDirection;
            vec3 L2 = normalize(spatialReservoir.position - surfaceInteraction.position);
            SurfaceMaterialInteractionSplitWeight brdf2 = opaqueSurfaceMaterialInteractionCalcProjectedWeight(opaqueSurfaceMaterialInteraction, minimalRayInteraction2, L2);
            indirectLight += spatialReservoir.radiance * (brdf2.diffuseReflectionWeight + brdf2.diffuseTransmissionWeight) * spatialReservoir.avgWeight;        
            if (opaqueSurfaceMaterialInteraction.isotropicRoughness > RAB_RESTIR_GI_MIN_ROUGHNESS)
            {
              indirectLight += spatialReservoir.radiance * brdf2.specularReflectionWeight * spatialReservoir.avgWeight;
            }
          }
          accumulateRadiance(pathState, indirectLight);
        }
    
        if (opaqueSurfaceMaterialInteraction.isotropicRoughness > RAB_RESTIR_GI_MIN_ROUGHNESS)
        {
          // For high roughness surface, restir gi can provide full indirect light and hence no more rays are needed.
          pathState.continuePath = false;
        }
        else
        {
          // For low roughness surface, restir gi cannot sample specular light effectively, so we need to trace specular ray.
          pathState.continuePath = pathState.continuePath && (continuationLobe != opaqueLobeTypeDiffuseReflection);
        }
    
        updateReSTIRGIHitDistance(oldLuminance, calcBt709Luminance(pathState.radiance), restirHitT, pathState.accumulatedHitDistance);
      }
    }
    
    // Update RestirGI hit distance until a rough surface is hit
    if (cb.enableReSTIRGI &&
        !pathState.restirGiHasFoundRoughSurface && 
        restirHitT > 0.h)
    {
      if (opaqueSurfaceMaterialInteraction.isotropicRoughness > cb.reSTIRGIVirtualSampleRoughnessThreshold ||
          continuationLobe == opaqueLobeTypeDiffuseReflection)
      {
        restirHitT = max(restirHitT, pathState.accumulatedHitDistance);
        pathState.restirGiHasFoundRoughSurface = true;
      }
    
      RestirGIRadiance[pathState.pixelCoordinate].a = restirHitT;
    }
#endif    
    
    // Terminate the path if requested
    // Note: Terminating here ensures no sampling is done for the final iteration.
    
    if (!pathState.continuePath)
    {
      return;
    }

#if ENABLE_NRC
    NrcSetBrdfPdf(pathState.nrcPathState, pathState.solidAnglePdf);
#endif

    accumulateThroughput(pathState, continuationThroughput);

#if (SURFACE_MATERIAL_RESOLVE_TYPE_ACTIVE_MASK & SURFACE_MATERIAL_RESOLVE_TYPE_RAY_PORTAL) != 0
  }
#endif // SURFACE_MATERIAL_RESOLVE_TYPE_RAY_PORTAL
}

// Update the hit distance when a significant contribution to the final result is found
void updateReSTIRGIHitDistance(inout float16_t oldLuminance, float16_t newLuminance, inout float16_t restirHitT, float16_t newHitT)
{
#if !ENABLE_NRC 
  // If both oldLuminance and newLuminance are 0, still update hit distance
  if (newLuminance >= oldLuminance * cb.reSTIRGIVirtualSampleLuminanceThreshold)
  {
    restirHitT = newHitT;
    oldLuminance = newLuminance;
  }
#else
  unused(oldLuminance);
  unused(restirHitT);
#endif  
}

vec3 calculateReSTIRGIRadianceFactor(
  GeometryFlags geometryFlags,
  float16_t primaryPerceptualRoughness,
  float16_t firstSampledLobePdf,
  float16_t firstSampledSolidAnglePdf,
  vec3 firstLobeThroughput)
{
  // pathState.radiance = L * fi * cosA / (solidAnglePdf * lobePdf)
  // throughput = fi * cosA / (solidAnglePdf * lobePdf)
  float16_t isotropicRoughness = calcRoughness(primaryPerceptualRoughness);
  const float16_t diffuseLobeProbability = geometryFlags.firstSampledLobeIsSpecular ?
    float16_t(1.0) - firstSampledLobePdf : firstSampledLobePdf;

  // Only skip specular lobe when diffuse probability is high enough.
  const float16_t minDiffuseProbability = 0.05;

  if (!kRestirGIAcceptLowRoughnessInput && isotropicRoughness < float16_t(RAB_RESTIR_GI_DELTA_ROUGHNESS) && diffuseLobeProbability > minDiffuseProbability)
  {
    // For low roughness surface, only diffuse samples are input to ReSTIR GI.
    // So the input to ReSTIR GI should be L / (solidAnglePdf * lobePdf)
    if (geometryFlags.firstSampledLobeIsSpecular)
    {
      return 0;
    }
    else
    {
      return 1.0 / max(firstSampledSolidAnglePdf * firstSampledLobePdf * firstLobeThroughput, vec3(1e-7));
    }
  }
  else
  {
    // For high roughness surface, both diffuse and specular samples are accepted.
    // So the input to ReSTIR GI should be L / solidAnglePdf
    return 1.0 / max(firstSampledSolidAnglePdf * firstLobeThroughput, vec3(1e-7));
  }
}

// Restore the ReSTIR GI radiance factor from the texture and multiply it by the actual radiance.
// Can't use the radiance written out to the IndirectRadiance for ReSTIR GI
// because there's firefly filtering applied to the radiance values stored in these textures, and that biases the results.
// This looks kind of stupid because we just wrote this radiance factor to a texture earlier in this function,
// but it's actually better than storing the factor in a variable. That would result in the factor being spilled and filled
// multiple times as the integrator progresses through the scene, and with a texture store it's only spilled once.
void storeRestirGIRadiance(PathState pathState, GeometryFlags geometryFlags, float16_t gbufferSurfaceHitDistance)
{
#if !ENABLE_NRC  
  if (!(cb.enableReSTIRGI && geometryFlags.primarySelectedIntegrationSurface))
  {
    return;
  }

  f16vec4 restirGIRadianceFactorHitDistance = RestirGIRadiance[pathState.pixelCoordinate];
  vec3 restirGIRadiance = restirGIRadianceFactorHitDistance.rgb * pathState.radiance;
  float luminance = calcBt709Luminance(restirGIRadiance);
  float luminanceFactor = min(1.0, float16Max / luminance);
  restirGIRadiance *= luminanceFactor;

  // Calculate indirect portion of the path length
  float16_t restirGIHitDistance = max(restirGIRadianceFactorHitDistance.a - gbufferSurfaceHitDistance, 0.0);

  // Sign bit for non opaque hit
  if (!pathState.restirGiHasHitOpaque)
  {
    restirGIRadiance.x *= -1;
  }

  RestirGIRadiance[pathState.pixelCoordinate] = f16vec4(restirGIRadiance, restirGIHitDistance);
#endif  
}

#if ENABLE_NRC
// Loads radiance integrated for a path prior to indirect integrate pass for an NRC update pass
vec3 loadIntegratedRadiancePriorToIntegrateIndirect(
  u16vec2 nrcPixelCoordinate,
  u16vec2 gbufferPixelCoordinate,
  PathState pathState,
  GeometryFlags geometryFlags) 
{
  // Reload integrated radiance up to this point for training paths as that is what NRC expects.
  // NRC does not care about nor manage the path state radiance for query paths. 
  // In query paths, it is up to the path tracer to manage it, so we skip reloading it here and 
  // preserve default non-NRC behavior of the integrator
  if (pathState.isNrcQuery)
  {
    return vec3(0.f);
  }  
  // Direct lighting radiance
  vec3 directLightingRadiance;
  {
    vec3 diffuseRadiance;
    vec3 specularRadiance;

    if (geometryFlags.primarySelectedIntegrationSurface)
    { 
      diffuseRadiance = PrimaryDirectDiffuseLobeRadianceHitDistance[gbufferPixelCoordinate].xyz;
      specularRadiance = PrimaryDirectSpecularLobeRadianceHitDistance[gbufferPixelCoordinate].xyz;
    }
    else
    {
      diffuseRadiance = SecondaryCombinedDiffuseLobeRadianceHitDistance[gbufferPixelCoordinate].xyz;
      specularRadiance = SecondaryCombinedSpecularLobeRadianceHitDistance[gbufferPixelCoordinate].xyz;
    }

    directLightingRadiance = diffuseRadiance + specularRadiance;
  }

  const vec3 primarySurfaceRadiance = vec3(
    NrcTrainingGBufferSurfaceRadianceRG[nrcPixelCoordinate], 
    NrcTrainingGBufferSurfaceRadianceB[nrcPixelCoordinate]);

  return primarySurfaceRadiance + directLightingRadiance;
}
#endif

// Initializes NRC state for the begining of Indirect path resolve.
// Sets pathState.continuePath to false if the path should terminate
void initNrc(
  inout PathState pathState,
  u16vec2 gbufferPixelCoordinate,
  bool isNrcUpdate,
  GeometryFlags geometryFlags,
  float16_t firstSampledSolidAnglePdf)
{
#if ENABLE_NRC
  pathState.isNrcUpdate = isNrcUpdate;

  if (isNrcUpdate) 
  {
    pathState.throughputFullPath = f16vec3(1.h);
  }

  // Cache the coordinate since it's calculated
  const u16vec2 nrcPixelCoordinate = pathState.pixelCoordinate;

  // Reload NRC path state
  NrcProgressState prevHitNrcProgressState;
  
  if (isNrcUpdate)
  {
    // Note: NrcPathData0 is unused for isNrcUpdate
    pathState.nrcPathState = Nrc::loadNrcPathState(nrcPixelCoordinate, !isNrcUpdate, prevHitNrcProgressState, NrcPathData0, NrcUpdatePathData1);
  }
  else
  {
    pathState.nrcPathState = Nrc::loadNrcPathState(nrcPixelCoordinate, isNrcUpdate, prevHitNrcProgressState, NrcPathData0, NrcPathData1);
  }

  // Gbuffer pass writes out final path info for query paths with NrcProgressState::TerminateImmediately on primary hit,
  // and we don't pass all the data needed to do so from GBuffer pass, so disable duplicatively writing it again
  pathState.writeFinalPathInfo = isNrcUpdate || prevHitNrcProgressState != NrcProgressState::TerminateImmediately;

  if (cb.debugView == DEBUG_VIEW_NRC_UPDATE_IS_UNBIASED && isNrcUpdate)
  {
    storeInDebugView(nrcPixelCoordinate, NrcGetFlag(pathState.nrcPathState.packedData, nrcPathFlagIsUnbiased));
  }

  // Handle Nrc progress state from primary surface hit at this time
  if (prevHitNrcProgressState == NrcProgressState::TerminateImmediately ||
      prevHitNrcProgressState == NrcProgressState::TerminateAfterDirectLighting)
  {
    // Invalidate Direct Lighting contribution if NRC asked for it.
    // Note: This is not a common scenario since it is undesirable to sample the cache at vertex 0.
    //   This can however happen for debug cases, such as when visualizing the cache at vertex 0.
    //   The reason this state resolve is delayed to indirect pass is that because Direct Lighting pass is aliased
    //   for both training and query paths and both of which can possibly end up with a different progress state
    if (prevHitNrcProgressState == NrcProgressState::TerminateImmediately &&
        // Training paths do not use the following buffers after the indirect pass so there is no need to clear them
        pathState.isNrcQuery)
    {
      PrimaryDirectDiffuseLobeRadianceHitDistance[gbufferPixelCoordinate] = vec4(vec3(0), kEmptyPixelHitDistance);
      PrimaryDirectSpecularLobeRadianceHitDistance[gbufferPixelCoordinate] = vec4(vec3(0), kEmptyPixelHitDistance);
      SecondaryCombinedDiffuseLobeRadianceHitDistance[gbufferPixelCoordinate] = vec4(vec3(0), kEmptyPixelHitDistance);
      SecondaryCombinedSpecularLobeRadianceHitDistance[gbufferPixelCoordinate] = vec4(vec3(0), kEmptyPixelHitDistance);
    }

    pathState.continuePath = false;
    return;
  }

  pathState.radiance += loadIntegratedRadiancePriorToIntegrateIndirect(nrcPixelCoordinate, gbufferPixelCoordinate, pathState, geometryFlags);
  
  // ToDo: obsolete comment?
  // Note: Remix PT separates throughput prior to GBuffer hit and after, so thus NRC doesn't change it on a GBuffer hit for training paths. 
  // Therefore, default non-NRC behavior applies to it - we keep the one already initialized in the PathState

  NrcSetBrdfPdf(pathState.nrcPathState, firstSampledSolidAnglePdf);
#else
  unused(pathState);
#endif
}

void writeToNrcOutputsAfterIntegration(PathState pathState)
{
#if ENABLE_NRC
  Nrc::setNrcMode(pathState.isNrcUpdate);

  // Cache the coordinate since it's calculated
  const u16vec2 pixelCoordinate = pathState.pixelCoordinate;

  const NrcContext nrcContext = Nrc::createNrcContext(pixelCoordinate);
    
  // Sanitize the inputs since they occasionally have NaNs
  pathState.radiance = NrcSanitizeNansInfs(pathState.radiance);
  pathState.throughput = NrcSanitizeNansInfs(pathState.throughput);

  // Note: A path had a bounce index increased when it exits, so it is the same case 
  // as if a new indirect hit was hit when debug registering radiance on NRC hit
  Nrc::debugRegisterNrcRadiance(pixelCoordinate, pathState.isNrcUpdate,
    pathState.bounceIteration, pathState.radiance, pathState.throughput, false, cb.debugView);

  if (pathState.writeFinalPathInfo)
  {
    NrcWriteFinalPathInfo(nrcContext, pathState.nrcPathState, pathState.throughput, pathState.radiance);
  }
#endif
}

void initReSTIRGI(
  PathState pathState,
  GeometryFlags geometryFlags,
  float16_t firstHitPerceptualRoughness,
  float16_t firstSampledLobePdf,
  float16_t firstSampledSolidAnglePdf)
{
#if !ENABLE_NRC
  if (cb.enableReSTIRGI && geometryFlags.primarySelectedIntegrationSurface)
  {
    // Pre-calculate the radiance factor to reduce live state dragged over the integrator
    // Note: Using throughput passed from the direct lighting integrator, not the path state throughput. Additionally uses first sampled
    // lobe and solid angle pdf from the direct lighting integrator as this data is only available there.
    const vec3 restirGIRadianceFactor = calculateReSTIRGIRadianceFactor(
      geometryFlags, firstHitPerceptualRoughness, firstSampledLobePdf, firstSampledSolidAnglePdf, pathState.throughput);

    // Output the radiance factor for ReSTIR GI and other information into the reservoir.
    // The actual radiance is reconstructed in the temporal reuse pass from the indirect textures that are written out later in the integrator.
    RestirGIRadiance[pathState.pixelCoordinate] = f16vec4(min(restirGIRadianceFactor, float16Max), 0);
  }
#endif
}

void integrateIndirectPath(
  // Pixel coordinate corresponding to the gbuffer source data for this thread
  // Note: gbuffer prefix is appended to differentiate gbufferPixelCoordinate from pathState.pixelCoordinate 
  //       which in case of an NRC update is different from gbuffer pixel coordinate.
  u16vec2 gbufferPixelCoordinate,
  uint indirectSbtOffset,
  IndirectPathTextures indirectPathTextures,
  GeometryFlags geometryFlags, uint16_t mediumMaterialIndex, vec3 rayOrigin, f16vec3 rayDirection,
  f16vec3 throughput, float16_t rayConeRadius, float16_t firstHitPerceptualRoughness,
  float16_t firstSampledLobePdf, float16_t firstSampledSolidAnglePdf,
  float16_t gbufferSurfaceHitDistance, bool isNrcUpdate)
{
  // Initialize Path State
  // Note: Not technically live state as this is only passed into the resolve call and reconstructed from its output.
  PathState pathState = pathStateCreateEmpty(geometryFlags);

  // Note: Carry over relevant state from the direct lighting integration. These are currently the only values which
  // need to be set, the rest can remain as default.
  pathState.origin = rayOrigin;
  pathState.coneRadius = rayConeRadius;
  pathState.direction = rayDirection;
  pathState.mediumMaterialIndex = mediumMaterialIndex;
  pathState.throughput = throughput;
  pathState.insideMedium = geometryFlags.insideMedium;
  pathState.accumulatedHitDistance = gbufferSurfaceHitDistance;
  pathState.solidAnglePdf = asfloat(NeeCacheThreadTask[gbufferPixelCoordinate].x);
  pathState.coneSpreadAngle = calculateSpreadAngleFromSolidAnglePdf(pathState.coneSpreadAngle, firstSampledSolidAnglePdf);
  // Enable nee cache for PSR reflection, which cannot be handled by ReSTIR GI.
  pathState.enableNeeCacheAfterFirstBounce =
    (geometryFlags.performPSRR || NEECache.shouldUseHigherBounceNeeCache(geometryFlags.firstSampledLobeIsSpecular, calcRoughness(firstHitPerceptualRoughness)));
  pathState.gbufferPerceptualRoughness = firstHitPerceptualRoughness;
  
  initNrc(pathState, gbufferPixelCoordinate, isNrcUpdate, geometryFlags, firstSampledSolidAnglePdf);

  initReSTIRGI(pathState, geometryFlags, firstHitPerceptualRoughness, firstSampledLobePdf, firstSampledSolidAnglePdf);

  // Note: Initialize the continue path flag based on if an indirect ray should actually be cast, e.g. if the PDF
  // and throughput are non-zero (as these being 0 indicates often that the sampled ray direction is invalid and should
  // not be used).
  if (firstSampledSolidAnglePdf == 0.0h)
  {
    pathState.continuePath = false;
  }

  pathState.continuePath &= any(pathState.throughput > 0.0h);

  if (pathState.continuePath)
  {
    if (NEE_CACHE_ENABLE && cb.neeCacheArgs.enable) 
    {
      RAB_RandomSamplerState rtxdiRNG = RAB_InitRandomSampler(pathState.pixelCoordinate, cb.frameIdx, pathState.bounceIteration);
      uint jitter = sampleUniformIntRng(rtxdiRNG);
      MinimalSurfaceInteraction gbuffer = minimalSurfaceInteractionReadFromGBuffer(gbufferPixelCoordinate, indirectPathTextures.PrimaryWorldPositionWorldTriangleNormal);
      if(gbuffer.isValid)
      {
        pathState.neeCacheCellOffset = NEECache.pointToOffset(rayOrigin, gbuffer.triangleNormal, jitter);
      }
    }

#ifdef OPAQUE_MATERIAL_USE_POM
    // Set initial POM material and texcoords from textures.
    if (pathState.continuePath && cb.pomEnableIndirectLighting && geometryFlags.pomOpaqueSurfaceEncountered)
    {
      uint16_t primarySurfaceIndex = uint16_t(SharedSurfaceIndex[gbufferPixelCoordinate]);
      
      if (cb.debugView == DEBUG_VIEW_HEIGHT_MAP && TRUE_OR_CHECK_WHEN_NRC_ENABLED(pathState.isNrcQuery))
      {
        if (primarySurfaceIndex != BINDING_INDEX_INVALID)
        {
          const MemoryPolymorphicSurfaceMaterial memoryPolymorphicSurfaceMaterial = surfaceMaterials[primarySurfaceIndex];
          if (memoryPolymorphicSurfaceMaterial.isOpaque())
          {
            OpaqueSurfaceMaterial opaqueSurfaceMaterial = opaqueSurfaceMaterialCreate(memoryPolymorphicSurfaceMaterial);
            
            if (opaqueSurfaceMaterial.heightTextureIndex == BINDING_INDEX_INVALID)
            {
              storeInDebugView(getDispatchRaysIndex().xy, float3(1.f, 1.f, 0.f));
            }
          }
          else
          {
            storeInDebugView(getDispatchRaysIndex().xy, float3(1.f, 0.5f, 0.f));
          }
        }
        else
        {
          storeInDebugView(getDispatchRaysIndex().xy, float3(1.f, 0.f, 0.f));
        }
      }

      if (primarySurfaceIndex != BINDING_INDEX_INVALID)
      {
        const MemoryPolymorphicSurfaceMaterial memoryPolymorphicSurfaceMaterial = surfaceMaterials[primarySurfaceIndex];
        if (memoryPolymorphicSurfaceMaterial.hasValidDisplacement())
        {
          OpaqueSurfaceMaterial opaqueSurfaceMaterial = opaqueSurfaceMaterialCreate(memoryPolymorphicSurfaceMaterial);
    
          MinimalSurfaceInteraction minimalSurfaceInteraction = minimalSurfaceInteractionReadFromGBuffer(
            gbufferPixelCoordinate, indirectPathTextures.PrimaryWorldPositionWorldTriangleNormal);
    
          const float pomThroughput = opaqueSurfaceMaterialInteractionCalcHeightThroughput(
            minimalSurfaceInteraction, pathState.direction, opaqueSurfaceMaterial, SharedTextureCoord[gbufferPixelCoordinate]
          );
  
          accumulateThroughput(pathState, pomThroughput);
          pathState.continuePath = any(pathState.throughput > 0.001h);
          pathState.continueResolving = pathState.continuePath;
        }
      }
    }
#endif
  }

  // Integrate Secondary Vertices

  if (cb.enableSecondaryBounces)
  for (; pathState.continuePath; ++pathState.bounceIteration)
  {
    // Note: Set to false to be set to true only if the path should continue in the path vertex function.
    // This is done to easily account for the various cases the path vertex function may return on
    // which do not require path extension.
    pathState.continuePath = false;

    pathState.decalEncountered = false;

    // Create a secondary Ray from the Path State

    // Todo: Find a better way to construct this, ideally a
    // version without tMax when we have generic functions,
    // and a constructor to take individual values.
    Ray secondaryRay;
    secondaryRay.origin = pathState.origin;
    secondaryRay.coneRadius = pathState.coneRadius;
    secondaryRay.direction = pathState.direction;
    secondaryRay.tMax = floatMax;

    // Trace the secondary ray and integrate the secondary vertex

    // If we're inside a solid translucent object, we can't use backface culling
    // (otherwise we don't hit the other side of the object)
    uint flags = pathState.insideMedium ? 0 : RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
    flags |= RAY_FLAG_FORCE_OPAQUE;

    RESOLVE_RAY_TRACE(
      indirectPathTextures, secondaryRay, flags, indirectSbtOffset,
      integratePathVertex,
      cb.secondaryRayMaxInteractions, pathState,
      SEGMENT_HIT_DISTANCE_UNUSED,
      DEBUG_VIEW_SECONDARY_RAY_INTERACTIONS, 
      DEBUG_VIEW_SECONDARY_RAY_AND_UNORDERED_INTERACTIONS,
      TRUE_OR_CHECK_WHEN_NRC_ENABLED(pathState.isNrcQuery));
  }

  u16vec2 gbufferPixelCoordinate = pathState.pixelCoordinate;

#if ENABLE_NRC
  if (pathState.isNrcUpdate)
  {
    gbufferPixelCoordinate = Nrc::calculateTrainingPixelCoordinateInQuerySpace(gbufferPixelCoordinate, cb.nrcArgs);
  }
#endif

  // Re-load geometry flags from the resource so that they're not carried around as live state during a ray path integration
  geometryFlags = geometryFlagsReadFromGBuffer(gbufferPixelCoordinate, SharedFlags);

  storeRestirGIRadiance(pathState, geometryFlags, gbufferSurfaceHitDistance);

  vec4 indirectOutData = vec4(pathState.radiance, pathState.firstBounceHitDistance);

  // Sanitize only primary indirect signal
  // Secondary indirect signal is sanitized in demodulate pass after radiance contribution from the direct lighting is added
  if (geometryFlags.primarySelectedIntegrationSurface)
  {
    indirectOutData = sanitizeRadianceHitDistance(indirectOutData.xyz, indirectOutData.w);
  }

  // Store the integrated ray path radiance and hit distance
  if (TRUE_OR_CHECK_WHEN_NRC_ENABLED(pathState.isNrcQuery))
  {
    indirectPathTextures.IndirectRadianceHitDistance[gbufferPixelCoordinate] = indirectOutData;
  }
  
  writeToNrcOutputsAfterIntegration(pathState);

  integratorIndirectPathOutputDebugView(
    indirectPathTextures,
    pathState,
    geometryFlags);
}

void integratorIndirectPathOutputDebugView(
  IndirectPathTextures indirectPathTexture,
  PathState pathState,
  GeometryFlags geometryFlags)
{
  if (!TRUE_OR_CHECK_WHEN_NRC_ENABLED(pathState.isNrcQuery))
  {
    return;
  }

  switch(cb.debugView)
  {
  default:
  case DEBUG_VIEW_DISABLED:
    break;
  case DEBUG_VIEW_SECONDARY_RAY_BOUNCES:
    // Revert the last bounceIteration increase on for loop exit
    storeInDebugView(pathState.pixelCoordinate, pathState.bounceIteration - (cb.enableSecondaryBounces ? 1 : 0));
    break;
  }
}
