/*
* Copyright (c) 2023-2024, NVIDIA CORPORATION. All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a
* copy of this software and associated documentation files (the "Software"),
* to deal in the Software without restriction, including without limitation
* the rights to use, copy, modify, merge, publish, distribute, sublicense,
* and/or sell copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
#pragma once

// Note: resolve.h must be first include to define required structures
#include "rtx/algorithm/resolve.h"
#include "rtx/utility/common.slangh"
#include "rtx/utility/math.slangh"
#include "rtx/utility/packing.slangh"
#include "rtx/utility/froxel.slangh"
#include "rtx/concept/ray/ray.slangh"
#include "rtx/concept/surface/surface.slangh"
#include "rtx/concept/surface_material/surface_material.slangh"
#include "rtx/concept/volume/volume.slangh"
#include "rtx/concept/volume_material/volume_material.slangh"
#include "rtx/concept/ray_portal/ray_portal.slangh"
#include "rtx/algorithm/view_distance.slangh"
#include "rtx/algorithm/volume_lighting.slangh"

// In testing, going from 3 to 4 bins made a large difference. Going from 4 to 5 or 5 to 6 changed only a few pixels.
// It was hard to produce visible differences by going above 6.
static const uint numDecalResolveBins = 4;

// Resolve Helper Functions

bool isRayMaskEmpty(uint8_t rayMask)
{
  return rayMask == 0;
}

void updateStateOnPortalCrossing(inout PortalSpace2BitsType portalSpace, 
                                 inout uint8_t rayMask, 
                                 uint8_t rayPortalIndex, 
                                 bool hasRayOriginatedFromViewModel)
{
  PortalSpace2BitsType newPortalSpace = 0;
  uint8_t newDynamicMask = 0;

  switch(uint(portalSpace)) 
  {
  case PORTAL_SPACE_NONE:
  {
    newPortalSpace = PORTAL_SPACE_PORTAL_0 + rayPortalIndex;

    newDynamicMask = rayPortalIndex == cb.virtualInstancePortalIndex
      ? OBJECT_MASK_VIEWMODEL_VIRTUAL | OBJECT_MASK_PLAYER_MODEL
      : OBJECT_MASK_ALL_PLAYER_MODEL;

    if (rayMask & OBJECT_MASK_PLAYER_MODEL)
      newDynamicMask |= OBJECT_MASK_PLAYER_MODEL_VIRTUAL;

    break;
  }
  case PORTAL_SPACE_PORTAL_0:
  case PORTAL_SPACE_PORTAL_1: 
    uint8_t prevEntryRayPortalIndex = portalSpace - PORTAL_SPACE_PORTAL_0;
    if (rayPortalIndex == prevEntryRayPortalIndex)
    {
      newPortalSpace = PORTAL_SPACE_PORTAL_COMBINED;
      newDynamicMask = OBJECT_MASK_ALL_PLAYER_MODEL;
    }
    else
    { // Reentering the main space
      newPortalSpace = PORTAL_SPACE_NONE;

      if (rayMask & OBJECT_MASK_PLAYER_MODEL_VIRTUAL)
        newDynamicMask |= OBJECT_MASK_PLAYER_MODEL;
      if (rayMask & OBJECT_MASK_PLAYER_MODEL)
        newDynamicMask |= OBJECT_MASK_PLAYER_MODEL_VIRTUAL;
    }
    break;

  case PORTAL_SPACE_PORTAL_COMBINED:
    // Do nothing. Stay in combined space. Technically a ray could go back to immediate portal space 
    // but we'd need more state and logic to resolve it since a ray could be several layers deep into the combined space. 
    // Ignoring it for now until we hit a scenario where it's needed
    newPortalSpace = PORTAL_SPACE_PORTAL_COMBINED;
    // ViewModel instances are not visible in combined space
    newDynamicMask = OBJECT_MASK_ALL_PLAYER_MODEL;
    break;
  }

#ifdef RAY_TRACING_PRIMARY_RAY
  rayMask = (rayMask & ~OBJECT_MASK_ALL_VIEWMODEL) | (newDynamicMask & OBJECT_MASK_ALL_VIEWMODEL);

  if (cb.enablePlayerModelInPrimarySpace)
    newDynamicMask |= OBJECT_MASK_PLAYER_MODEL;

#else // Indirect Rays 
  rayMask &= ~OBJECT_MASK_ALL_VIEWMODEL;

  // Keep including ViewModel instances as long as the ray originated from a ViewModel surface
  if (hasRayOriginatedFromViewModel)
    rayMask = rayMask | (newDynamicMask & OBJECT_MASK_ALL_VIEWMODEL);
#endif

  rayMask = (rayMask & ~OBJECT_MASK_ALL_PLAYER_MODEL) | (newDynamicMask & OBJECT_MASK_ALL_PLAYER_MODEL);

  portalSpace = newPortalSpace;
}

void updateStateOnPortalCrossing<T:IBasePayloadState>(inout T resolveVertexState, uint8_t rayPortalIndex)
{
#ifdef RAY_TRACING_PRIMARY_RAY
  const bool hasRayOriginatedFromViewModel = false;
#else // Indirect Rays
  const bool hasRayOriginatedFromViewModel = resolveVertexState.rayMask & OBJECT_MASK_ALL_VIEWMODEL;
#endif

  updateStateOnPortalCrossing(resolveVertexState.portalSpace, resolveVertexState.rayMask, rayPortalIndex, hasRayOriginatedFromViewModel);
}

bool evaluateOpaqueApproximations(
  uint8_t resolveMode,
  Surface surface, SurfaceInteraction surfaceInteraction,
  OpaqueSurfaceMaterialInteraction opaqueSurfaceMaterialInteraction,
  PortalSpace2BitsType portalSpace,
  // Note: Radiance attenuation split into incoming/outgoing rather than having the function accumulate into it
  // to accomodate some processes optimize around the fact that opaque approximations only result in monochromatic attenuation.
  f16vec3 incomingRadianceAttenuation, inout float16_t outgoingRadianceAttenuation, inout vec3 emissiveRadiance)
{
  const Camera camera = cb.camera;
  const VolumeArgs volumeArgs = cb.volumeArgs;
  const float16_t opacity = opaqueSurfaceMaterialInteraction.opacity;

  // Handle lighting approximations
  // Note: This has to be done with macros (unfortunately) due to the dependency on the volumetric radiance cache. Slang
  // sadly does not support the compile time lazy code evaluation to make this any more elegant as far as I know. Currently this
  // logic is only needed by the g-buffer pass which only deals with "primary" rays, but if we needed this in the integrator for
  // some reason (like better quality particles in rough-ish reflections not covered by PSR) we'd want to find a non-macro way
  // to do this so that this code does not run for NEE visibility rays in the same file as that would be not useful and bad for performance.

#ifdef RESOLVE_OPACITY_LIGHTING_APPROXIMATION
  // Note: Only perform the lighting approximation on particles using opacity, not just every surface using opacity.
  const bool opacityLightingApprox = surface.isParticle || packedFlagGet(resolveMode, resolveModeForceOpacityLightingApprox);

  if (opacityLightingApprox)
  {
    const uint froxelVolumeHint = portalSpaceToVolumeHint(portalSpace);

    const vec3 accumulatedOutgoingRadiance = evalVolumetricNEE(VolumeFilteredRadiance, volumeArgs,
      surfaceInteraction, froxelVolumeHint);

    // Note: Volume radiance cache assumes isotropic scattering (no directionality), but we want something closer to a "diffuse" distribution for
    // the surface of a particle rather than a volumetric contribution, so we multiply it by 4 here (albedo * 4 * radiance / (4 * pi) = albedo / pi).
    // Secondly, in the future this should use spherical harmonics to convert to a diffuse (or perhaps some sort of directional HG phase function to allow
    // for some contribution from behind) distribution so more directionality is respected rather than this simple multiply by 4 hack (which is not super physically correct).
    // Finally, albedo has opacity baked into it already so it does not need to be multiplied in here.
    emissiveRadiance += float16_t(4.0f) * opaqueSurfaceMaterialInteraction.albedo * accumulatedOutgoingRadiance * incomingRadianceAttenuation;
  }
#else
  const bool opacityLightingApprox = false;
#endif

  // Handle typical emissive and attenuation approximations

  const bool opacityTransmissionApprox = packedFlagGet(resolveMode, resolveModeOpacityTransmissionApprox);
  const bool emissiveOpacityTransmissionApprox = packedFlagGet(resolveMode, resolveModeEmissiveOpacityTransmissionApprox);

  // Note: Approximate opacity attenuation and emission when requested rather than returning a hit. Note while normal opacity transmission
  // approximation is always done if requested, emissive opacity transmission approximation is only done when an emissive blend mode is in use,
  // allowing objects with normal opacity behavior to be hit normally. Additionally, this logic is used when opacity lighting approximations are
  // in place as this indicates that no opacity hits should be counted ever due to approximating the lighting manually without the need for a hit.
  if ((emissiveOpacityTransmissionApprox && surface.isEmissiveBlend) || opacityTransmissionApprox || opacityLightingApprox)
  {
    // Note: Accumulate the material's emission into the radiance approximation as this can be calculated on any hit arbitarily. This factors the
    // attenuation across the resolve iterations in before emissive (to not cause self-attenuation) similar to any other path tracing loop in the project.
    emissiveRadiance +=
      opaqueSurfaceMaterialInteractionEvalEmissiveRadiance(opaqueSurfaceMaterialInteraction) *
      incomingRadianceAttenuation;
    // Note: Accumulate opacity into the radiance approximation, actually a perfect representation of the effects of
    // opacity on visibility rays. This is done for both approximation modes as this resolve hit is being skipped in either
    // case and this attenuation should give a more proper approximation for more complex emissive blending modes.
    outgoingRadianceAttenuation *= float16_t(1.0f) - opacity;
    // Todo: Potentially evaluate ambient here too like we do for emission? Doesn't depend on light direction or anything
    // either, but ideally we want to get rid of the ambient term some day so we'll skip it for now.

    return true;
  }

  // Note: If no approximation was handled, treat as a hit where relevant.
  return false;
}

bool evaluateTranslucentApproximations(
  uint8_t resolveMode,
  Surface surface, SurfaceInteraction surfaceInteraction,
  TranslucentSurfaceMaterialInteraction translucentSurfaceMaterialInteraction,
  f16vec3 incomingRadianceAttenuation, inout float16_t outgoingRadianceAttenuation, inout vec3 emissiveRadiance)
{
  unused(outgoingRadianceAttenuation);
  unused(emissiveRadiance);
  
  // Handle typical attenuation approximations

  const bool translucencyTransmissionApprox = packedFlagGet(resolveMode, resolveModeTranslucencyTransmissionApprox);

  if (translucencyTransmissionApprox)
  {
    // Todo: Accumulate emission into emissive radiance on entry hit.
    // Todo: Attenuate by fresnel factor on entry/exit points.
    // Todo: Handle volume attenuation by adding in attenuation on the exiting hit of transmission and
    // blindly having the ray go right through translucent objects like we did in the previous Aperture renderer.
    // Note thin translucency can be approximated perfectly and uses a slightly different path. Note this will require
    // returning to f16vec3 attenuation fully which will not play well with the current implementation of how the unordered
    // approximations are handled, so it may require packing the color down into fewer bits or perhaps doing things
    // differently (a fully ordered approach would solve a lot of this complexity and make the translucency approximations much
    // easier to evaluate.)

    return true;
  }

  // Note: If no approximation was handled, treat as a hit where relevant.
  return false;
}

// Resolve Functions

// Handles updating of the resolve state after each iteration when resolving is intended to continue.
// Mainly used to update ray origin and teleport through Ray Portals.
void resolveVertexFinalContinue<T : IBasePayloadState>(
  Ray ray, SurfaceInteraction surfaceInteraction,
  bool teleport, mat4 teleportMatrix,
  inout T resolveVertexState)
{
  // Update ray origin to move past the current interaction

  if (teleport)
  {
    // Teleport matrix already includes ray offset to avoid self-intersection with the exit portal
    resolveVertexState.origin = (mul(teleportMatrix, vec4(surfaceInteraction.position, 1.0f))).xyz;
    resolveVertexState.direction = normalize(f16vec3(mul(mat3(teleportMatrix), vec3(resolveVertexState.direction))));
  }
  else
  {
    // Note: This will cause slight floating point error along the ray as the origin is shifted around without updating the direction,
    // but it is likely fine. Ideally the tMin value instead could just be updated, but the hardware may not start the ray at tMin, resulting in excessive work.
    // Note: Triangle normal always faces the viewer, so using it negated will always allow the ray to be pushed through the triangle hit. This is important to properly offset
    // the ray to allow it to continue, using the ray direction instead will not work on triangles at a grazing angle.
    resolveVertexState.origin = rayOffsetSurfaceOriginHelper(surfaceInteraction, true);
  }
}

// Handles updating of the resolve state after an iteration when resolving is intended to stop on a hit.
void resolveVertexFinalHit<T : IBasePayloadState>(inout T resolveVertexState)
{
  // Indicate that resolving should be stopped now that a hit is found

  resolveVertexState.continueResolving = false;
}

// Handles updating of the resolve state after an iteration when resolving is intended to stop on a miss specifically
// (not to be confused with stopping on a hit which simply requires setting the continue resolving flag to false).
void resolveVertexFinalMiss<let overrideRayInteraction : bool, T : IBasePayloadState>(
  inout T resolveVertexState,
  inout RayInteraction rayInteraction,
  inout f16vec3 radianceAttenuation)
{
  unused(radianceAttenuation);

  // Set the hit distance for this segment of the ray to a miss and indicate that resolving should be stopped

  resolveVertexState.segmentHitDistance = kMissHitDistance;
  resolveVertexState.continueResolving = false;

  // Override the Ray Interaction with a miss
  // Note: This is somewhat redundant on rays which are already a miss (which is why a compile time bool is able to be passed
  // to ensure this redundant operation can be skipped), but is needed when misses are to be simulated when actually hitting geometry
  // (this is used for clip planes and the view distance).

  if (overrideRayInteraction)
  {
    rayInteraction = rayInteractionCreateMiss();
  }

  // Account for attenuation on miss
  // Note: This is important for any effects which apply after miss, such as potential future skybox effects.

#ifdef RESOLVER_USE_VOLUMETRIC_ATTENUATION
  radianceAttenuation *= evalVolumetricAttenuation(cb.volumeArgs, false, 0.0f);
#endif
}

// Resolves a single vertex of the resolve loop. Note this should be called first thing from the function handling the hit logic.
// Emissive radiance and attenuation may be accumulated immediately but the continueResolving flag must be checked to see if the
// function should return and continue attempting to resolve an interaction. If false, the Ray Interaction can then be checked
// for a hit and hit logic can be performed.
void resolveVertex<T: IBasePayloadState>(
  uint8_t resolveMode,
  RayHitInfo rayHitInfo, inout T resolveVertexState,
  inout Ray ray, inout RayInteraction rayInteraction,
  inout Surface surface, inout SurfaceInteraction surfaceInteraction,
  inout PolymorphicSurfaceMaterialInteraction polymorphicSurfaceMaterialInteraction,
  inout f16vec3 radianceAttenuation, inout vec3 emissiveRadiance,
  uint4 decalMemory,
  f16vec3 decalEmissiveRadiance,
  float16_t coneSpreadAngle,
  inout bool isStochasticAlphaBlend,
  inout uint8_t firstRayPortal,
  inout bool pomOpaqueSurfaceEncountered,
  inout bool isRaytracedRenderTarget,
  // Forces enablement of ray portal resolve path regardless of global resolve mask 
  // Needed for RayQuery paths for visibility rays from CHS as they don't run material specific hit groups
  // Visibility rays are expected not to start from RayPortal surfaces, and thus only RayPortal path is force enabled
  const bool forceEnableResolveRayPortal = false,
  const bool useStochasticAlphaBlend = false)
{
  const Camera camera = cb.camera;
  bool teleport = false;
  mat4 teleportMatrix = mat4(1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 0, 1);

  // Set the default value we want to use when nothing opaque is hit
  pomOpaqueSurfaceEncountered = false;

  // Create a Ray and Ray Interaction from the hit

  // Todo: Use minimal ray or something else when we have generic functions as this has
  // no tMax value as nothing needs it.

  ray.origin = resolveVertexState.origin;
  ray.coneRadius = resolveVertexState.coneRadius;
  ray.spreadAngle = coneSpreadAngle;
  ray.direction = resolveVertexState.direction;

  rayInteraction = rayInteractionCreate(ray, rayHitInfo);

  // Note: Return misses to the caller as no further work needs to be done (this is assumed to be checked by the caller to know if surface/material information has been populated).
  if (!rayInteractionHasHit(rayInteraction))
  {
    // Note: Ray interaction is already a miss here, so no need for this function to override it.
    resolveVertexFinalMiss<false>(resolveVertexState, rayInteraction, radianceAttenuation);

    return;
  }

  resolveVertexState.segmentHitDistance = rayInteraction.hitDistance;
  // Note: Update the state with the newly calculated cone radius from this segment's interaction.
  resolveVertexState.coneRadius = rayInteraction.coneRadius;

  // Apply Volumetric attenuation for this resolve segment
  // Note: Volume attenuation can be calculated on a per-segment basis here rather than all at once in compositing
  // as e^x * e^y (where x/y are hit distances) is the same as e^(x + y).

#ifdef RESOLVER_USE_VOLUMETRIC_ATTENUATION
  radianceAttenuation *= evalVolumetricAttenuation(cb.volumeArgs, true, rayHitInfo.hitDistance);
#endif

  // Create a Surface and Surface Interaction from the hit

  surface = surfaces[uint(rayInteraction.surfaceIndex)]; 

  surfaceInteraction = surfaceInteractionCreate<SurfaceGenerateTangents>(surface, rayInteraction, ray);

  // Process user clip planes and view distance

  if (isSurfaceClipped(surface, surfaceInteraction) && resolveVertexState.continueResolving)
  {
    // Continue resolving when we hit a clipped geometry to find possible objects behind it.
    resolveVertexFinalContinue(ray, surfaceInteraction, teleport, teleportMatrix, resolveVertexState);
    return;
  }

  if (!evalViewDistance(cb.viewDistanceArgs, cb.isZUp, camera, surfaceInteraction.position))
  {
    // Note: Treat view distance interactions as misses as no geometry should be processed past them
    // (since these operations essentially clip out everything beyond them in a specific direction).
    resolveVertexFinalMiss<true>(resolveVertexState, rayInteraction, radianceAttenuation);
    return;
  }

  // Create a Surface Material and Surface Material Interaction from the Surface

  const MemoryPolymorphicSurfaceMaterial memoryPolymorphicSurfaceMaterial = surfaceMaterials[uint(rayInteraction.surfaceIndex)];
  
  const uint8_t polymorphicType = rayInteraction.materialType;

  // Handle special logic for specific material types

  const bool separateUnorderedApproximations = packedFlagGet(resolveMode, resolveModeSeparateUnorderedApproximations);
  const bool decalMaterialBlending = packedFlagGet(resolveMode, resolveModeDecalMaterialBlending);

  if (SURFACE_MATERIAL_RESOLVE_TYPE_ACTIVE_MASK & SURFACE_MATERIAL_RESOLVE_TYPE_OPAQUE &&
      polymorphicType == surfaceMaterialTypeOpaque)
  {
    const OpaqueSurfaceMaterial opaqueSurfaceMaterial = opaqueSurfaceMaterialCreate(memoryPolymorphicSurfaceMaterial);

    OpaqueSurfaceMaterialInteraction opaqueSurfaceMaterialInteraction =
      opaqueSurfaceMaterialInteractionCreate(opaqueSurfaceMaterial, surface, surfaceInteraction, rayInteraction);

    // Blend any decal(s) that happened before this interaction
    if (decalMaterialBlending && resolveVertexState.decalEncountered)
    {
      MemoryDecalMaterialInteraction memory;
      memory.packed = decalMemory;
      memory.emissiveRadiance = decalEmissiveRadiance;
      DecalMaterialInteraction decalMaterialInteraction = decalMaterialInteractionUnpack(memory);

      decalMaterialInteractionBlend(decalMaterialInteraction, opaqueSurfaceMaterialInteraction);
      
      resolveVertexState.decalEncountered = false;
    }

    // must create this after decal has been composited to opaque surface material interaction
    polymorphicSurfaceMaterialInteraction =
      polymorphicSurfaceMaterialInteractionCreateInternal(opaqueSurfaceMaterialInteraction);

    // Raytraced Render Target
    // If we hit a surface that has a render target texture bound then get the associated camera index and
    // the texture coordinates of the surface we hit
    if (cb.enableRaytracedRenderTarget && opaqueSurfaceMaterial.flags & OPAQUE_SURFACE_MATERIAL_FLAG_IS_RAYTRACED_RENDER_TARGET)
    {
      isRaytracedRenderTarget = true;

      resolveVertexFinalHit(resolveVertexState);

      return;
    }
    else
    {
      isRaytracedRenderTarget = false;
    }

    // Note: Fully opaque surfaces have no chance at needing further resolving (since they are gauranteed to have no opacity-related blending or translucency), so stopping here is fine.
    // Todo: Incorporate decals into this check so this can be moved above the decal logic for early outing sooner on most hits?
    if (surface.isFullyOpaque)
    {
      // Cache if this surface is a POM material for later use
      pomOpaqueSurfaceEncountered = opaqueSurfaceMaterial.hasValidDisplacement();

      resolveVertexFinalHit(resolveVertexState);

      return;
    }

    // Note: Backfacing hits on opaque materials for now are not considered as they have no relevant contribution for lighting. This may change however if thin opaque surfaces are added.
    // Backfacing triangles on translucent materials still need to be checked as translucency is handled with resolve functions just like everything else, as well as likely needing them for
    // translucency approximation in the future.
    // Todo: Perhaps re-enable this if we get consistent front/back faces in the future? This will affect illumination from backfacing objects however though so this might not look correct if enabled.
    //if (!rayInteraction.frontHit)
    //{
    //  return;
    //}

    const float16_t opacity = opaqueSurfaceMaterialInteraction.opacity;

    // Handle nearly-opaque early out case

    // Note: Early out if opacity is set to completely opaque to stop the resolving early.
    if (opacity >= cb.resolveOpaquenessThreshold)
    {
      // Cache if this surface is a POM material for later use
      pomOpaqueSurfaceEncountered = opaqueSurfaceMaterial.hasValidDisplacement();

      resolveVertexFinalHit(resolveVertexState);
      return;
    }

    // Handle opaque approximations

    // Note: Disable opaque approximations when the separate unordered approximations flag is enabled as
    // this approximation logic will be done in the unordered resolve step.
    if (!separateUnorderedApproximations)
    {
      float16_t opaqueApproximationOutgoingAttenuation = float16_t(1.0f);
      const bool approximationHandled = evaluateOpaqueApproximations(
        resolveMode,
        surface, surfaceInteraction, opaqueSurfaceMaterialInteraction,
        resolveVertexState.portalSpace,
        radianceAttenuation, opaqueApproximationOutgoingAttenuation, emissiveRadiance);

      radianceAttenuation *= opaqueApproximationOutgoingAttenuation;

      if (approximationHandled)
      {
        // Note: Must call resolve final on any return which expects resolving to continue.
        resolveVertexFinalContinue(ray, surfaceInteraction, teleport, teleportMatrix, resolveVertexState);

        return;
      }
    }

#ifdef RAY_TRACING_PRIMARY_RAY
    // Handle nearly-transparent early out logic and stochastic alpha blend
    bool handleStochasticAlphaBlend = 
      useStochasticAlphaBlend && cb.enableStochasticAlphaBlend &&
      opacity > cb.resolveTransparencyThreshold && opacity <= cb.resolveStochasticAlphaBlendThreshold;

    isStochasticAlphaBlend = handleStochasticAlphaBlend;
#else
    unused(isStochasticAlphaBlend);
    bool handleStochasticAlphaBlend = false;
#endif

    // Note: Early out if opacity is less than the threshold to avoid doing any material evaluation on nearly transparent surfaces.
    // Stochastic alpha blend is also handled here
    if (opacity <= cb.resolveTransparencyThreshold || handleStochasticAlphaBlend)
    {
      // Note: Must call resolve final on any return which expects resolving to continue.
      resolveVertexFinalContinue(ray, surfaceInteraction, teleport, teleportMatrix, resolveVertexState);

      return;
    }
  }
  else if (SURFACE_MATERIAL_RESOLVE_TYPE_ACTIVE_MASK & SURFACE_MATERIAL_RESOLVE_TYPE_TRANSLUCENT &&
           polymorphicType == surfaceMaterialTypeTranslucent)
  {
    const TranslucentSurfaceMaterial translucentSurfaceMaterial = translucentSurfaceMaterialCreate(memoryPolymorphicSurfaceMaterial);

    TranslucentSurfaceMaterialInteraction translucentSurfaceMaterialInteraction =
      translucentSurfaceMaterialInteractionCreate(translucentSurfaceMaterial, surface, surfaceInteraction, rayInteraction);

    // Blend any decal(s) that happened before this interaction
    if (decalMaterialBlending && resolveVertexState.decalEncountered)
    {
      MemoryDecalMaterialInteraction memory;
      memory.packed = decalMemory;
      memory.emissiveRadiance = decalEmissiveRadiance;
      DecalMaterialInteraction decalMaterialInteraction = decalMaterialInteractionUnpack(memory);

      decalMaterialInteractionBlend(decalMaterialInteraction, translucentSurfaceMaterialInteraction);

      resolveVertexState.decalEncountered = false;
    }

    polymorphicSurfaceMaterialInteraction =
      polymorphicSurfaceMaterialInteractionCreateInternal(translucentSurfaceMaterialInteraction);

    // Handle translucent approximations

    // Note: Disable translucent approximations when the separate unordered approximations flag is enabled as
    // this approximation logic will be done in the unordered resolve step.
    const bool translucencyTransmissionApprox = packedFlagGet(resolveMode, resolveModeTranslucencyTransmissionApprox);
    if (!separateUnorderedApproximations || translucencyTransmissionApprox)
    {
      float16_t translucentApproximationOutgoingAttenuation = float16_t(1.0f);
      const bool approximationHandled = evaluateTranslucentApproximations(
        resolveMode,
        surface, surfaceInteraction, translucentSurfaceMaterialInteraction,
        radianceAttenuation, translucentApproximationOutgoingAttenuation, emissiveRadiance);

      radianceAttenuation *= translucentApproximationOutgoingAttenuation * translucentSurfaceMaterialInteraction.transmittanceColor;

      if (approximationHandled)
      {
        // Note: Must call resolve final on any return which expects resolving to continue.
        resolveVertexFinalContinue(ray, surfaceInteraction, teleport, teleportMatrix, resolveVertexState);

        return;
      }
    }
  }
  else if ((SURFACE_MATERIAL_RESOLVE_TYPE_ACTIVE_MASK & SURFACE_MATERIAL_RESOLVE_TYPE_RAY_PORTAL || forceEnableResolveRayPortal) &&
           polymorphicType == surfaceMaterialTypeRayPortal)
  {
    const RayPortalSurfaceMaterial rayPortalSurfaceMaterial = rayPortalSurfaceMaterialCreate(uint(rayInteraction.surfaceIndex), memoryPolymorphicSurfaceMaterial);

    const RayPortalSurfaceMaterialInteraction rayPortalSurfaceMaterialInteraction =
      rayPortalSurfaceMaterialInteractionCreate(rayPortalSurfaceMaterial, surface, surfaceInteraction);

    polymorphicSurfaceMaterialInteraction =
      polymorphicSurfaceMaterialInteractionCreateInternal(rayPortalSurfaceMaterialInteraction);

    // Render Portal outline
    {
      const bool portalFadeInEffect = cb.enablePortalFadeInEffect && rayPortalSurfaceMaterial.maskTextureIndex != BINDING_INDEX_INVALID;
      const float16_t tFactor = portalFadeInEffect ? float16_t((surface.tFactor >> 24) & 0xff) / 255.0 : float16_t(0.0);
      const float16_t ringTransparency =
        saturate(float16_t(1) - rayPortalSurfaceMaterialInteraction.mask.a) *
        (rayPortalSurfaceMaterialInteraction.isInsidePortal ? saturate(float16_t(1) - tFactor) : 1);
      // Hack: Lingering 0.5 from earlier in the project to make the Portal less bright before it had its own material, too late to remove this now for
      // Portal RTX, but this should be removed some day.
      const float16_t hackPortalEmissiveIntensity = 0.5f;

      emissiveRadiance +=
        (rayPortalSurfaceMaterialInteraction.mask.rgb * (float16_t(1.0f) - ringTransparency) * hackPortalEmissiveIntensity) * radianceAttenuation;
      radianceAttenuation *= ringTransparency;
    }

    // Assume the portal ring is opaque
    const float opaqueThreshold = 0.02;
    if (calcBt709Luminance(radianceAttenuation) < opaqueThreshold)
    {
      resolveVertexFinalHit(resolveVertexState);
    }

    if (!rayPortalSurfaceMaterialInteraction.isInsidePortal)
    {
      // Note: Must call resolve final on any return which expects resolving to continue.
      resolveVertexFinalContinue(ray, surfaceInteraction, teleport, teleportMatrix, resolveVertexState);

      return;
    }

    // Find Ray Portal Hit Info

    const uint8_t rayPortalIndex = rayPortalSurfaceMaterialInteraction.rayPortalIndex;
    RayPortalHitInfo rayPortalHitInfo = cb.rayPortalHitInfos[uint(rayPortalIndex)];

    if (rayPortalHitInfoIsActive(rayPortalHitInfo))
    {
      // Discard any decals that may be located above the portal,
      // mostly because portals are pushed closer to the walls in our renderer.
      resolveVertexState.decalEncountered = false;

      updateStateOnPortalCrossing(resolveVertexState, rayPortalIndex);

      // If the ray mask was zeroed out, finish resolving and return this as a miss to the caller
      if (isRayMaskEmpty(resolveVertexState.rayMask))
      {
        resolveVertexFinalMiss<true>(resolveVertexState, rayInteraction, radianceAttenuation);

        return;
      }

      teleportMatrix = rayPortalHitInfo.encodedPortalToOpposingPortalDirection.unpack();
      teleport = true;

      // Note: Ray Portals will almost always change the ray direction, so indicate this to the caller.
      if (packedFlagGet(resolveMode, resolveModeAlteredDirectionNotify))
      {
        resolveVertexState.directionAltered = true;
      }

      // Note: Report the Ray Portal index if requested and if this is the first Ray Portal hit.
      if (packedFlagGet(resolveMode, resolveModeRayPortalNotify) && firstRayPortal == invalidRayPortalIndex)
      {
        firstRayPortal = rayPortalIndex;
      }

    #ifdef RAY_TRACING_PRIMARY_RAY
      // Update the virtual matrix. We load the inverse teleport matrix here instead 
      // to avoid doing the inverse on the final virtualMatrix later
      const uint8_t opposingRayPortalIndex = getOpposingRayPortalIndex(rayPortalIndex);
      const f16vec4 inverseTeleportQuaternion = cb.rayPortalHitInfos[uint(opposingRayPortalIndex)].encodedPortalToOpposingPortalDirection.unpackRotation();
      resolveVertexState.accumulatedRotation = quaternionMultiply(resolveVertexState.accumulatedRotation, inverseTeleportQuaternion);
    #endif
    }

    // Note: Must call resolve final on any return which expects resolving to continue.
    resolveVertexFinalContinue(ray, surfaceInteraction, teleport, teleportMatrix, resolveVertexState);

    // Note: Continue resolving if the Ray Portal was inactive or if it was traversed.
    return;
  }

  // Indicate resolving is finished in the absence of any need to continue

  resolveVertexFinalHit(resolveVertexState);
}

// Finds the lowest bin in terms of distance and outputs its index as well as other associated information.
void findLowestBin(
  f16mat4 binnedRadiancesAndAttenuation, f16vec4 binDistances,
  inout uint lowestIndex, inout float16_t lowestDistance, inout f16vec4 lowestRadianceAndAttenuation)
{
  // Find the lowest distance and the index associated with it in the bins

  lowestIndex = 0;
  lowestDistance = binDistances.x;

  for (uint i = 1; i < 4; ++i)
  {
    const float16_t currentDistance = selectComponent(binDistances, i);

    if (currentDistance < lowestDistance)
    {
      lowestDistance = currentDistance;
      lowestIndex = i;
    }
  }

  // Extract the radiance and attenuation based on the index

  lowestRadianceAndAttenuation = selectColumn(binnedRadiancesAndAttenuation, lowestIndex);
}

static RNG resolveVertexUnorderedRng = createRngAnywhere(cb.frameIdx, 555);

void conditionallyStoreDecal(
  inout MemoryDecalMaterialInteraction bins[numDecalResolveBins],
  inout uint orders[numDecalResolveBins],
  const DecalMaterialInteraction decalMaterialInteraction,
  uint decalSortKey)
{

  
  // 1st, return any unused bins
  uint result = 0;
  for (uint i = 0; i < numDecalResolveBins; ++i)
  {
    if (orders[i] == uintMax)
    {
      // found an unused bin, just use it
      orders[i] = decalSortKey;
      bins[i] = decalMaterialInteractionPack(decalMaterialInteraction);
      return;
    }
  }

  // 2nd, if the most transparent decal's opacity is below the threshold and below the new decal, overwrite it.
  float16_t lowestOpacity = float16Max;
  for (uint i = 0; i < numDecalResolveBins; ++i)
  {
    float16_t opacity = decalMaterialInteractionExtractOpacity(bins[i].packed);
    if (opacity < lowestOpacity)
    {
      result = i;
      lowestOpacity = opacity;
    }
  }
  
  // Use a randomized value to dither the transition between different decals being chosen.
  const float decalSortingOpacityThreshold = 0.1f * getNextSampleBlueNoise(resolveVertexUnorderedRng) + 0.025f;
  if (lowestOpacity < decalSortingOpacityThreshold && lowestOpacity < decalMaterialInteraction.opacity && decalMaterialInteraction.opacity > decalSortingOpacityThreshold)
  {
    orders[result] = decalSortKey;
    bins[result] = decalMaterialInteractionPack(decalMaterialInteraction);
    return;
  }

  // New decal is mostly transparent and all binned decals are more opaque, so ignore the new one.
  if (decalMaterialInteraction.opacity <= decalSortingOpacityThreshold)
  {
    return;
  }

  // 3rd, if all decals are above the opacity threshold, overwrite the lowest one.
  uint lowestSortOrder = uintMax;
  for (uint i = 0; i < numDecalResolveBins; ++i)
  {
    if (orders[i] < lowestSortOrder)
    {
      lowestSortOrder = orders[i];
      result = i;
    }
  }
  if (lowestSortOrder < decalSortKey)
  {
    orders[result] = decalSortKey;
    bins[result] = decalMaterialInteractionPack(decalMaterialInteraction);
  }

  // NOTE: it may be possible to get a better result by preferring to discard decals that are behind a mostly opaque decal.
}

// Unordered resolve rays need to be a little bit longer than the regular resolve ray that generated the hitT.
// In some cases, there is a blended surface very close to a wall, and using the original hitT results in
// Z-fighting between the blended surface and the wall.
// The value has been determined experimentally.
static const float kUnorderedResolveRayLengthening = 1.001;

// Translates the ray mask for the main TLAS into the ray mask for the unordered TLAS.
uint8_t convertPrimaryRayMaskToUnordered(uint8_t primaryRayMask, uint8_t unorderedRayMask)
{
  return (primaryRayMask & OBJECT_MASK_ALL_DYNAMIC) | unorderedRayMask;
}

// Handles unordered Resolve operations within the resolve loop which do not depend on the typical ordered execution
// for the resolve logic.
void resolveVertexUnordered<let RAY_FLAGS : uint8_t>(
  uint8_t resolveMode, Ray ray, uint rayMask,
  PortalSpace2BitsType portalSpace,
  bool useIntersectionBillboards,
#ifdef RAY_TRACING_PRIMARY_RAY
  u16vec2 pixelCoordinate,
  f16vec4 accumulatedRotation,
#endif
  float accumulatedHitDistance,
  float16_t pathSelectionProbability,
  inout f16vec3 radianceAttenuation, inout vec3 emissiveRadiance,
  out uint numInteractions,
  inout bool decalEncountered,
  inout uint4 decalMemory,
  inout f16vec3 decalEmissiveRadiance,
  inout int surfaceIndex)
{
  // Early out if approximations are not desired to be separated out

  const bool separateUnorderedApproximations = packedFlagGet(resolveMode, resolveModeSeparateUnorderedApproximations);

  if (!separateUnorderedApproximations)
  {
    surfaceIndex = -1;
    numInteractions = 0;
    return;
  }

  uint rayFlags = RAY_FLAG_CULL_OPAQUE;

  if (useIntersectionBillboards)
    rayMask &= OBJECT_MASK_UNORDERED_ALL_INTERSECTION_PRIMITIVE | OBJECT_MASK_ALL_DYNAMIC;
  else
    rayMask &= OBJECT_MASK_UNORDERED_ALL_GEOMETRY | OBJECT_MASK_ALL_DYNAMIC;

  // Loop over each non-opaque object in the ray's path

  RayQuery<RAY_FLAGS> rayQuery = RayQuery<RAY_FLAGS>();
  {
    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    rayDesc.TMin = 0;
    rayDesc.TMax = ray.tMax;
    rayQuery.TraceRayInline(unorderedTLAS, RAY_FLAGS, rayMask, rayDesc);
  }

  // Note: The number of actual relevant hits along the unordered traversal.
  numInteractions = 0;

  // Note: Initialize bins to completely transparent with no radiance to be added in at an impossibly low distance. This
  // ensures these filler items are pulled out first in sorted order, giving the incoming elements a few iterations to populate
  // the bins.
  f16mat4 binnedRadiancesAndAttenuation = f16mat4(
    f16vec4(0.0f, 0.0f, 0.0f, 1.0f),
    f16vec4(0.0f, 0.0f, 0.0f, 1.0f),
    f16vec4(0.0f, 0.0f, 0.0f, 1.0f),
    f16vec4(0.0f, 0.0f, 0.0f, 1.0f),
  );
  f16vec4 binDistances = f16vec4(-1.0f, -1.0f, -1.0f, -1.0f);

#ifdef RAY_TRACING_PRIMARY_RAY
  MemoryDecalMaterialInteraction binnedDecals[numDecalResolveBins];
  uint binnedDecalSortOrder[numDecalResolveBins] = {uintMax, uintMax, uintMax, uintMax};
  uint maxSortOrder = 0;
  // TODO[REMIX-3080] Unusued for now, will be needed for normal blending
  // f16mat3 worldToDecalTangent = f16mat3(0);
  const uint kMaxUnorderedResolveSteps = 64;
#else
  float minDecalSample = -1.f;
  uint maxOpaqueSortOrder = 0;
  uint sampledSortOrder = 0;
  const uint kMaxUnorderedResolveSteps = 32;
#endif

  for (uint step=0 ; step<kMaxUnorderedResolveSteps && rayQuery.Proceed() ; step++)
  {
    RayHitInfo rayHitInfo;
    RayInteraction rayInteraction;
    SurfaceInteraction surfaceInteraction;

    // Note: Using template parameter here, which should eliminate this branch for gbuffer (since we dont use intersection AABBs there in most cases).
    const bool isTriangle = (RAY_FLAGS & RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES) || rayQuery.CandidateType() == CANDIDATE_NON_OPAQUE_TRIANGLE;

    if (isTriangle)
    {
      RAY_HIT_INFO_CREATE_RAY_QUERY_CANDIDATE(rayHitInfo, rayQuery)

      // Create a Ray Interaction from the hit info

      rayInteraction = rayInteractionCreate(ray, rayHitInfo);
    }
    else
    {
      MemoryBillboard billboard = billboards[rayQuery.CandidateInstanceID()];
      
      float3 normal;

      if (packedFlagGet(billboard.flags, billboardFlagIsBeam))
      {
        // Find the orientation of a cylinder section along the Y axis that provides the largest
        // angle between the section plane and the incoming ray.
        float3 xAxis = cross(billboard.yAxis, ray.direction);

        // Use the normalized cross product as the X axis. If the ray is parallel to the Y axis,
        // just keep the existing X axis because it doesn't matter - there will be no intersection.
        float xLength = length(xAxis);
        if (xLength > 0)
          billboard.xAxis = xAxis / xLength;

        normal = cross(billboard.xAxis, billboard.yAxis);
      }
#ifdef RAY_TRACING_PRIMARY_RAY
      else if (!packedFlagGet(billboard.flags, billboardFlagIsCameraFacing))
      {
        // For primary rays, just rotate the billboard using the accumulatedRotation.
        // Note: multiplying on the left because we need the inverse transform
        billboard.xAxis = quaternionTransformVector(quaternionInverse(accumulatedRotation), billboard.xAxis);
        billboard.yAxis = quaternionTransformVector(quaternionInverse(accumulatedRotation), billboard.yAxis);
      
        normal = normalize(cross(billboard.xAxis, billboard.yAxis));
      }
#endif
      else
      {
        // For secondary rays, we don't have the accumulatedRotation, so get creative:
        // reorient the billboard so that it faces the virtual camera, i.e. the image of the camera
        // below the surface where the ray originated from. Do not use the ray origin for the 
        // virtual camera position because that results in heavy distortions of particle shapes
        // in reflections.

        // Original normal
        normal = normalize(cross(billboard.xAxis, billboard.yAxis));

        const float3 virtualCameraPosition = ray.origin - ray.direction * accumulatedHitDistance;
        const float3 reorientedNormal = normalize(virtualCameraPosition - billboard.center);
        
        // If the new normal is facing the opposite direction, just flip it, because
        // rotation becomes unstable near the opposite pole. We don't care much for the exact particle
        // rotation in reflections etc. but stability is desirable.
        if (dot(normal, reorientedNormal) < 0.0)
          normal = -normal;
        
        // Find a quaternion that transforms the original normal into the new one.
        const f16vec4 rotationQuat = quaternionCreateOrientation(normal, reorientedNormal);

        // Use that quaternion to rotate the billboard.
        // This is more predictable than re-creating a basis just from the normal.
        billboard.xAxis = quaternionTransformVector(rotationQuat, billboard.xAxis);
        billboard.yAxis = quaternionTransformVector(rotationQuat, billboard.yAxis);
        normal = reorientedNormal;
      }

      // Compute the ray-plane intersection.
      const float NdotD = dot(ray.direction, normal);
      float t = dot(billboard.center - ray.origin, normal) / NdotD;
      if (isinf(t) || isnan(t)) t = -1.0;

      if (0 > t || t > ray.tMax)
        continue;

      vec3 p = ray.origin + ray.direction * t;
      vec3 cToP = p - billboard.center.xyz;
      vec2 uv;
      uv.x = dot(cToP, billboard.xAxis) * billboard.inverseHalfWidth;
      uv.y = dot(cToP, billboard.yAxis) * billboard.inverseHalfHeight;

      if (max(abs(uv.x), abs(uv.y)) >= 1.0)
        continue;

      uv = uv.x * billboard.xAxisUV + uv.y * billboard.yAxisUV + billboard.centerUV;

      f16vec4 vertexColor;
      vertexColor.x = unorm8ToF16(uint8_t(billboard.vertexColor >> 16));
      vertexColor.y = unorm8ToF16(uint8_t(billboard.vertexColor >> 8));
      vertexColor.z = unorm8ToF16(uint8_t(billboard.vertexColor));
      vertexColor.w = unorm8ToF16(uint8_t(billboard.vertexColor >> 24));

      rayHitInfo.hitDistance = t;

      rayInteraction.surfaceIndex = billboard.surfaceIndex;
      rayInteraction.hitDistance = t;
      rayInteraction.barycentricCoordinates = 0;
      rayInteraction.primitiveIndex = 0;
      rayInteraction.customIndex = 0;
      rayInteraction.frontHit = NdotD < 0;
      rayInteraction.materialType = billboard.materialType;

      // Calculate texture gradient
      float16_t coneRadius = ray.coneRadius + float16_t(ray.spreadAngle * t);
      float16_t textureGradientFactor = 4.0f; // This factor is based on experiment
      f16vec2 dUVRatio = coneRadius * textureGradientFactor * f16vec2(billboard.inverseHalfWidth, billboard.inverseHalfHeight);

      surfaceInteraction.position = p;
      surfaceInteraction.positionError = 0;
      surfaceInteraction.triangleNormal = normal;
      surfaceInteraction.triangleTangent = billboard.xAxis;
      surfaceInteraction.triangleBitangent = billboard.yAxis;
      surfaceInteraction.motion = 0;
      surfaceInteraction.textureCoordinates = uv;
      surfaceInteraction.textureGradientX = dUVRatio.x * billboard.xAxisUV;
      surfaceInteraction.textureGradientY = dUVRatio.y * billboard.yAxisUV;
      surfaceInteraction.interpolatedNormal = normal;
      surfaceInteraction.interpolatedTangent = billboard.xAxis;
      surfaceInteraction.interpolatedBitangent = billboard.yAxis;
      surfaceInteraction.vertexColor = vertexColor;
    }

    const Surface surface = surfaces[uint(rayInteraction.surfaceIndex)]; 

    if (isTriangle)
      surfaceInteraction = surfaceInteractionCreate<SurfaceGenerateTangents>(surface, rayInteraction, ray);

    // Test the hit surface against view distance and ignored surface clipping

    if (!evalViewDistance(cb.viewDistanceArgs, cb.isZUp, cb.camera, surfaceInteraction.position) || isSurfaceClipped(surface, surfaceInteraction))
    {
      // Note: Iteration skipped, we unfortunately cannot break the loop here as the hits are processed
      // in an undefined order rather than from closest to furthest like they are in the usual resovle loop,
      // so there may still be more unordered hits to resolve.
      continue;
    }

    // Create a Surface Material and Surface Material Interaction from the Surface

    const MemoryPolymorphicSurfaceMaterial memoryPolymorphicSurfaceMaterial = surfaceMaterials[uint(rayInteraction.surfaceIndex)];
    
    const uint8_t polymorphicType = rayInteraction.materialType;

    // Handle special approximation logic for specific material types

    // Note: Current iteration's radiance attenuation and emissive radiance separated out for manual unordered blending logic.
    float16_t currentRadianceAttenuation = float16_t(1.0f);
    vec3 currentEmissiveRadiance = vec3(0.0f);

    if (polymorphicType == surfaceMaterialTypeOpaque)
    {
      const OpaqueSurfaceMaterial opaqueSurfaceMaterial = opaqueSurfaceMaterialCreate(memoryPolymorphicSurfaceMaterial);

      const OpaqueSurfaceMaterialInteraction opaqueSurfaceMaterialInteraction =
        opaqueSurfaceMaterialInteractionCreate(opaqueSurfaceMaterial, surface, surfaceInteraction, rayInteraction);

      if (isTriangle && surfaceIsDecal(surface))
      {
        const float opacity = opaqueSurfaceMaterialInteraction.opacity;
        if (opacity > 0.001f && rayInteraction.frontHit)
        {
          uint decalSortKey = (uint(surface.decalSortOrder) << 24) + ((rayHitInfo.geometryIndex & 0xff) << 16) + (rayHitInfo.primitiveIndex & 0xffff);
          DecalMaterialInteraction decalMaterialInteraction = decalMaterialInteractionCreate(opaqueSurfaceMaterialInteraction);

#ifdef RAY_TRACING_PRIMARY_RAY
          conditionallyStoreDecal(binnedDecals, binnedDecalSortOrder, decalMaterialInteraction, decalSortKey);
          if (decalSortKey > maxSortOrder)
          {
            surfaceIndex = rayInteraction.surfaceIndex;
            maxSortOrder = decalSortKey;
            // TODO[REMIX-3080] Unusued for now, will be needed for normal blending
            // Note: Ideally this should be the final surface's tangent space, but in practice any decal's tangent space should work.
            // worldToDecalTangent = f16mat3(surfaceInteraction.interpolatedTangent, surfaceInteraction.interpolatedBitangent, surfaceInteraction.interpolatedNormal);
          }
#else
          // For indirect rays, use resevoir sampling (adapted to drop decals that are less than the topmost opaque decal we've seen)

          // Use weighted reservoir sampling (A-Res) from here: https://en.wikipedia.org/wiki/Reservoir_sampling
          float rngValue = pow(getNextSampleBlueNoise(resolveVertexUnorderedRng), 1.f / opacity);

          // We want to apply reservoir sampling to all decals that are not underneath a mostly opaque decal.
          // There are three cases where we want to sample the current decal:
          // 1) it's the first decal
          // 2) it's opaque and above the current sample
          // 3) it's not opaque, above the highest opaque, and it's reservoir sampling value is < the current sample.
          if (minDecalSample < 0.f || // case 1)
              (opacity > 0.95f && decalSortKey > sampledSortOrder) ||  // case 2)
              (decalSortKey > maxOpaqueSortOrder && rngValue < minDecalSample))  // case 3)
          {
            // use this decal
            MemoryDecalMaterialInteraction memory = decalMaterialInteractionPack(decalMaterialInteraction);
            decalMemory = memory.packed;
            decalEmissiveRadiance = memory.emissiveRadiance;
            surfaceIndex = rayInteraction.surfaceIndex;
            sampledSortOrder = decalSortKey;
            minDecalSample = rngValue;
          }

          // Track the highest opaque decal we've encountered separately, since we want to update the highest opaque even if we don't sample this decal.
          if (opacity > 0.95f && decalSortKey > maxOpaqueSortOrder)
          {
            maxOpaqueSortOrder = decalSortKey;
          }
#endif
          decalEncountered = true;
        }
      }
      else 
      {
        // Note: Return value ignored, should never return false in this path unless there is a bug. Additionally, incoming radiance attenuation
        // set to 1.0 as attenuation will be manually added in later.
        evaluateOpaqueApproximations(
          resolveMode | resolveModeForceOpacityLightingApprox,
          surface, surfaceInteraction, opaqueSurfaceMaterialInteraction, portalSpace,
          f16vec3(1.0f), currentRadianceAttenuation, currentEmissiveRadiance);
      }
    }
    else if (polymorphicType == surfaceMaterialTypeTranslucent)
    {
      const TranslucentSurfaceMaterial translucentSurfaceMaterial = translucentSurfaceMaterialCreate(memoryPolymorphicSurfaceMaterial);

      const TranslucentSurfaceMaterialInteraction translucentSurfaceMaterialInteraction =
        translucentSurfaceMaterialInteractionCreate(translucentSurfaceMaterial, surface, surfaceInteraction, rayInteraction);

      // Note: Return value ignored, should never return false in this path unless there is a bug. Additionally, incoming radiance attenuation
      // set to 1.0 as attenuation will be manually added in later.
      evaluateTranslucentApproximations(
        resolveMode,
        surface, surfaceInteraction, translucentSurfaceMaterialInteraction,
        f16vec3(1.0f), currentRadianceAttenuation, currentEmissiveRadiance);
    }

    if (!isTriangle || !surfaceIsDecal(surface))
    {
      // Calculate a blend softening factor
      // Note: This is done to avoid raster particles handled by this seprated logic from clipping in ugly ways against geometry by
      // fading out portions of particles closer to walls. Only done for Surfaces labeled as particles.

      const float16_t softBlendFactor = saturate((ray.tMax - rayHitInfo.hitDistance) / (ray.tMax * uint16BitsToHalf(cb.particleSoftnessFactor)));
      const float16_t blendFactor = surface.isParticle ? softBlendFactor : float16_t(1.0);

      currentRadianceAttenuation = mix(float16_t(1.0f), currentRadianceAttenuation, blendFactor);
      currentEmissiveRadiance = mix(vec3(0.0f), currentEmissiveRadiance, blendFactor);

      if (any(currentEmissiveRadiance) > 0)
      {
        surfaceIndex = rayInteraction.surfaceIndex;
      }

      // Find the lowest item in the bins

      uint lowestIndex;
      float16_t lowestDistance;
      f16vec4 lowestRadianceAndAttenuation;

      findLowestBin(
        binnedRadiancesAndAttenuation, binDistances,
        lowestIndex, lowestDistance, lowestRadianceAndAttenuation);

      // Accumulate the lowest bin into the radiance and attenuation

 #ifdef RESOLVER_USE_VOLUMETRIC_ATTENUATION
      // Note: Volume attenuation calculated only for the current ray start to the current hit surface, not accumulated
      // into the attenuation as this will be handled later by the ordered resolve logic (and we do not want to incorrectly
      // accumulate volume radiance multiple times for overlapping unordered segments).
      const f16vec3 volumeAttenuation = evalVolumetricAttenuation(cb.volumeArgs, true, lowestDistance);
#else
      // Note: Set to 1 here rather than removing it from the emissive radiance statement to not have to duplicate that code.
      const f16vec3 volumeAttenuation = f16vec3(1.0f, 1.0f, 1.0f);
#endif

      emissiveRadiance += lowestRadianceAndAttenuation.rgb * radianceAttenuation * volumeAttenuation;
      // Hack: This is done as a workaround for a compiler bug (REMIX-1551), should be revertex back to what it was originally to avoid
      // increased register pressure in resolving.
      radianceAttenuation = f16vec3(vec3(radianceAttenuation) * float(lowestRadianceAndAttenuation.a));
      // radianceAttenuation *= lowestRadianceAndAttenuation.a;

      // Replace the lowest bin with the current iteration's information

      writeColumn(binnedRadiancesAndAttenuation, f16vec4(currentEmissiveRadiance, currentRadianceAttenuation), lowestIndex);
      writeComponent(binDistances, float16_t(rayHitInfo.hitDistance), lowestIndex);
    }
    
    // Do picking (in non PSR primary rays) only, and also make sure to do it here to include decals

#ifdef RAY_TRACING_PRIMARY_RAY
#ifndef GBUFFER_PSR
    if (numInteractions == 0 && cb.enableObjectPicking != 0)
    {
      // Write only if was OBJECT_PICKING_INVALID, i.e. write the very first resolveVertexUnordered
      // Object picking for alpha blended
      InterlockedCompareStore(
        PrimaryObjectPicking[pixelCoordinate],
        OBJECT_PICKING_INVALID,    // compare to
        surface.objectPickingValue // value to write, if equal
      );
    }
#endif
#endif

    // Increment the hit count after a successful hit

    numInteractions += 1;
  }

  // Early out in the special case of nothing being hit
  // Note: This is a fairly common case since often rays travel unobstructed by particles or other intermediate objects, so having
  // a path to skip the somewhat costly bin flushing logic below results in a small performance improvement.

  if (numInteractions == 0)
  {
    return;
  }

  // Flush the bins by iterating through them and finding the lowest for each
  // Note: This has to be done as there will be remaining items in the bins (up to 4) which need to be accumulated in most cases after
  // the main loop finishes.

  for (uint i = 0; i < 4 ; ++i)
  {
    // Find the lowest item in the bins

    uint lowestIndex;
    float16_t lowestDistance;
    f16vec4 lowestRadianceAndAttenuation;

    findLowestBin(
      binnedRadiancesAndAttenuation, binDistances,
      lowestIndex, lowestDistance, lowestRadianceAndAttenuation);

    // Accumulate the lowest bin into the radiance and attenuation

    // Note: Volume attenuation calculated only for the current ray start to the current hit surface, not accumulated
    // into the attenuation as this will be handled later by the ordered resolve logic (and we do not want to incorrectly
    // accumulate volume radiance multiple times for overlapping unordered segments).
    const f16vec3 volumeAttenuation = evalVolumetricAttenuation(cb.volumeArgs, true, lowestDistance);

    emissiveRadiance += lowestRadianceAndAttenuation.rgb * radianceAttenuation * volumeAttenuation;
    // Hack: This is done as a workaround for a compiler bug (REMIX-1551), should be revertex back to what it was originally to avoid
    // increased register pressure in resolving.
    radianceAttenuation = f16vec3(vec3(radianceAttenuation) * float(lowestRadianceAndAttenuation.a));
    // radianceAttenuation *= lowestRadianceAndAttenuation.a;

    // Invalidate the lowest bin

    // Note: Invalid entry written in to safely be added if hit (in cases where fewer than 4 particle iterations
    // were done), but designed to always compare as further away from any valid item.
    writeColumn(binnedRadiancesAndAttenuation, f16vec4(0.0f, 0.0f, 0.0f, 1.0f), lowestIndex);
    writeComponent(binDistances, float16_t(float16Max), lowestIndex);
  }

#ifdef RAY_TRACING_PRIMARY_RAY
  if (decalEncountered)
  {
    DecalMaterialInteraction decalMaterialInteractionComposited;
    // draw decals from bottom to top (same order as the drawcalls are sent in)
    for (uint i = 0; i < numDecalResolveBins; ++i)
    {
      // find lowest decalSortOrder in bins to draw first
      uint sortOrder = uintMax;
      uint lowBin = 0;
      for (uint j = 0; j < numDecalResolveBins; ++j)
      {
        if (sortOrder > binnedDecalSortOrder[j])
        {
          lowBin = j;
          sortOrder = binnedDecalSortOrder[j];
        }
      }
      if (sortOrder == uintMax)
      {
        break;
      }
      if (i == 0)
      {
        decalMaterialInteractionComposited = decalMaterialInteractionUnpack(binnedDecals[lowBin]);
      }
      else
      {
        DecalMaterialInteraction decalMaterialInteraction = decalMaterialInteractionUnpack(binnedDecals[lowBin]);
        // TODO[REMIX-3080] need to adapt the normal blending to not be transforming into and out of the tangent space with every blend.
        // instead, should get the lowest decal's normal in its tangent space, transform each normal into that tangent space, and only go back to world space at the end.
        decalMaterialInteractionBlend(decalMaterialInteraction, decalMaterialInteractionComposited);
        // decalMaterialInteractionComposited = decalMaterialInteraction;
      }
      binnedDecalSortOrder[lowBin] = uintMax;
    }
    // write it to output values
    MemoryDecalMaterialInteraction memory = decalMaterialInteractionPack(decalMaterialInteractionComposited);
    decalMemory = memory.packed;
    decalEmissiveRadiance = memory.emissiveRadiance;
  }
#endif

  emissiveRadiance *= 1.h/pathSelectionProbability;
  decalEmissiveRadiance *= 1.h/pathSelectionProbability;
}

#if 0
#define RESOLVE(                                                                          \
  ray, flags,                                                                             \
  hitFunction, payloadEncodeFunction, payloadDecodeFunction,                              \
  maxInteractions, payload, encodedPayloadBinding,                                        \
  encodedPayloadBindingIndex, hitObjectBindingIndex)                                      \
{                                                                                         \
  /* Initialize the payload with the current ray's state */                               \
                                                                                          \
  Ray currentRay = ray;                                                                   \
                                                                                          \
  payload.origin = currentRay.origin;                                                     \
  payload.coneRadius = currentRay.coneRadius;                                             \
  payload.direction = currentRay.direction;                                               \
                                                                                          \
  /* Loop until a surface is resolved, or the maximum interaction count is hit */         \
                                                                                          \
  for (uint8_t interactionIteration = uint8_t(1);; ++interactionIteration)                \
  {                                                                                       \
    /* Reset the segment hit distance and continue resolving flag used for Resolve */     \
    /* logic for this next iteration                                               */     \
                                                                                          \
    payload.segmentHitDistance = 0.0f;                                                    \
    /* Note: Continue resolving flag set here to give the hit function a chance to */     \
    /* perform final actions when it is known to be on the last iteration of the   */     \
    /* resolve loop rather than terminating blindly.                               */     \
    payload.continueResolving = interactionIteration < maxInteractions;                   \
                                                                                          \
    /* Preform the ray trace with the desired information */                              \
                                                                                          \
    /* Note: Live state across this call (not put into payload as it is not */            \
    /* needed for anything on the hit function side of things):             */            \
    /* - interactionIteration                                               */            \
    /* - currentRay.tMax                                                    */            \
                                                                                          \
    TRACE_FUNCTION(                                                                       \
      currentRay, flags, uint(payload.rayMask),                                           \
      hitFunction, payloadEncodeFunction, payloadDecodeFunction,                          \
      payload, encodedPayloadBinding,                                                     \
      encodedPayloadBindingIndex, hitObjectBindingIndex);                                 \
                                                                                          \
    /* Check if the resolve loop should continue */                                       \
                                                                                          \
    if (!payload.continueResolving)                                                       \
    {                                                                                     \
      break;                                                                              \
    }                                                                                     \
                                                                                          \
    /* Update current ray for next iteration */                                           \
                                                                                          \
    currentRay.origin = payload.origin;                                                   \
    currentRay.direction = payload.direction;                                             \
    currentRay.tMax = max(currentRay.tMax - payload.segmentHitDistance, 0.0f);            \
  }                                                                                       \
}

// Generic Ray Trace resolve function, uses either Ray Query or
// Trace Ray depending on how things are compiled.
#define TRACE_FUNCTION RAY_TRACE
#define RESOLVE_RAY_TRACE(                                   \
  ray, flags,                                                \
  hitFunction, payloadEncodeFunction, payloadDecodeFunction, \
  maxInteractions, payload, encodedPayloadBinding,           \
  encodedPayloadBindingIndex, hitObjectBindingIndex)         \
RESOLVE(                                                     \
  ray, flags,                                                \
  hitFunction, payloadEncodeFunction, payloadDecodeFunction, \
  maxInteractions, payload, encodedPayloadBinding,           \
  encodedPayloadBindingIndex, hitObjectBindingIndex)
#undef TRACE_FUNCTION

#define TRACE_FUNCTION RAY_QUERY
#define RESOLVE_RAY_QUERY(                                   \
  ray, flags,                                                \
  hitFunction, payloadEncodeFunction, payloadDecodeFunction, \
  maxInteractions, payload, encodedPayloadBinding,           \
  encodedPayloadBindingIndex, hitObjectBindingIndex)         \
RESOLVE(                                                     \
  ray, flags,                                                \
  hitFunction, payloadEncodeFunction, payloadDecodeFunction, \
  maxInteractions, payload, encodedPayloadBinding,           \
  encodedPayloadBindingIndex, hitObjectBindingIndex)
#undef TRACE_FUNCTION
#endif

#include "resolve_expanded.slangh"
