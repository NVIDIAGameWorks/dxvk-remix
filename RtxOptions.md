# RTX Options
RTX Options are configurable parameters for RTX pipeline components. They can be set via rtx.conf in a following format:

```
<RTX Option int scalar> = <Integer value>
<RTX Option float scalar> = <Floating point value>
<RTX Option int vector> = <Integer value>, <Integer value>, ...
<RTX Option float vector> = <Floating point value>, <Floating point value>, ...
<RTX Option boolean> = True/False
<RTX Option string> = <String value, no quotes>
<RTX Option hash set/vector> = <Hex string>, <Hex string>, ...
```

Practical examples of syntax:

```
rtx.someIntScalar = 38
rtx.someFloatScalar = 29.39
rtx.someIntVector = 1, -2, 3
rtx.someFloatVector = 1.0, -2.0, 3.0
rtx.someBoolean = True
# Note: Leading whitespace in a string is removed, allowing for nicer option formatting like this without messing up the string.
# Additionally, strings should not be surrounded with quotes as these will be treated as part of the string.
rtx.someString = This is a string
# Note: 0x prefix on hash hex values here is optional, similarly these values are case-insensitive. 16 hex characters = 64 bit hash.
rtx.someHashSet = 8DD6F568BD126398, EEF8EFD4B8A1B2A5, ...
```

RTX Options may be set in multiple places, specifically a hardcoded set in `src/util/config/config.cpp` which is assigned per-application based on process name, and the two user-configurable files `dxvk.conf` and `rtx.conf`. If not set the options will inherit their default values.
The full order of precedence for how each set of options overrides the previous is as follows:

1. Default option value (Implicit)
2. `dxvk.conf` ("User Config")
3. Per-application `config.cpp` configuration ("Built-in Config")
4. `rtx.conf` ("RTX User Config")
  1. `baseGameModPath/rtx.conf` (Mod-specific extension of "RTX User Config")

Additionally, upon saving options from the Remix UI options are written only to rtx.conf.

Tables below enumerate all the options and their defaults set by RTX Remix. Note that this information is auto-generated by the RTX Remix application. To re-generate this file, run Remix with `DXVK_DOCUMENTATION_WRITE_RTX_OPTIONS_MD=1` defined in the environment variables.

## Simple Types
| RTX Option | Type | Default Value | Description |
| :-- | :-: | :-: | :-- |
|rtx.adaptiveAccumulation|bool|True||
|rtx.adaptiveResolutionDenoising|bool|True||
|rtx.adaptiveResolutionReservedGPUMemoryGiB|int|2|The amount of GPU memory in gibibytes to reserve away from consideration for adaptive resolution replacement textures\.<br>This value should only be changed to reflect the estimated amount of memory Remix itself consumes on the GPU \(aside from texture loading, mostly from rendering\-related buffers\) and should not be changed otherwise\.<br>Only relevant when force high resolution replacement textures is disabled and adaptive resolution replacement textures is enabled\. See asset estimated size parameter for more information\.<br>|
|rtx.allowCubemaps|bool|False|When enabled, cubemaps from the game are processed through Remix, but they may not render correctly\.|
|rtx.allowFSE|bool|False|A flag indicating if the application should be able to utilize exclusive full screen mode when set to true, otherwise force it to be disabled when set to false\.<br>Exclusive full screen may see performance benefits over other fullscreen modes at the cost of stability in some cases\.<br>Do note that on modern Windows full screen optimizations will likely be used regardless which in most cases results in performance similar to exclusive full screen even when it is not in use\.|
|rtx.alwaysCopyDecalGeometries|bool|True|When set to True tells the geometry processor to always copy decals geometry\. This is an optimization flag to experiment with when rtx\.useBuffersDirectly is True\.|
|rtx.alwaysWaitForAsyncTextures|bool|False|Force CPU to wait for the texture upload\. Do not use an asynchronous thread for textures\. If true, a frame stutter should be expected\.|
|rtx.antiCulling.light.enable|bool|False|Enable Anti\-Culling for lights\.|
|rtx.antiCulling.light.fovScale|float|1|Scalar of the FOV of lights Anti\-Culling Frustum\.|
|rtx.antiCulling.light.numFramesToExtendLightLifetime|int|1000|Maximum number of frames to keep  when Anti\-Culling is enabled\. Make sure not to set this too low \(then the anti\-culling won't work\), nor too high \(which will hurt the performance\)\.|
|rtx.antiCulling.light.numLightsToKeep|int|1000|Maximum number of lights to keep when Anti\-Culling is enabled\.|
|rtx.antiCulling.object.enable|bool|False|Extends lifetime of objects that go outside the camera frustum \(anti\-culling frustum\)\.|
|rtx.antiCulling.object.enableHighPrecisionAntiCulling|bool|True|Use robust intersection check with Separate Axis Theorem\.<br>This method is slightly expensive but it effectively addresses object flickering issues that arise from corner cases in the fast intersection check method\.<br>Typically, it's advisable to enable this option unless it results in a notable performance drop; otherwise, the presence of flickering artifacts could significantly diminish the overall image quality\.|
|rtx.antiCulling.object.enableInfinityFarFrustum|bool|False|Enable infinity far plane frustum for anti\-culling\.|
|rtx.antiCulling.object.farPlaneScale|float|10|Scale applied to the far plane for Anti\-Culling Frustum for matching the culling frustum in the original game\.|
|rtx.antiCulling.object.fovScale|float|1|Scale applied to the FOV of Anti\-Culling Frustum for matching the culling frustum in the original game\.|
|rtx.antiCulling.object.hashInstanceWithBoundingBoxHash|bool|True|Hash instances with bounding box hash for object duplication check\.<br> Disable this when the game using primitive culling which may cause flickering\.|
|rtx.antiCulling.object.numObjectsToKeep|int|10000|The maximum number of RayTracing instances to keep when Anti\-Culling is enabled\.|
|rtx.applicationId|int|102100511|Used to uniquely identify the application to DLSS\. Generally should not be changed without good reason\.|
|rtx.autoExposure.autoExposureSpeed|float|5|Average exposure changing speed \(in units per second\) when the image changes\.|
|rtx.autoExposure.centerMeteringSize|float|0.5|The importance of pixels around the screen center\.|
|rtx.autoExposure.enabled|bool|True|Automatically adjusts exposure so that the image won't be too bright or too dark\.|
|rtx.autoExposure.evMaxValue|float|5|Min/Max values tuned by moving from bright/dark locations in game, and adjusting until they look correct\.|
|rtx.autoExposure.evMinValue|float|-2|Min/Max values tuned by moving from bright/dark locations in game, and adjusting until they look correct\.|
|rtx.autoExposure.exposureAverageMode|int|1|Average mode\. Valid values: \<Mean=0, Median=1\>\. The mean mode averages exposures across pixels\. The median mode is more stable for extreme pixel values\.|
|rtx.autoExposure.exposureCenterMeteringEnabled|bool|False|Gives higher weight to pixels around the screen center\.|
|rtx.autoExposure.exposureWeightCurve0|float|1|Curve control point 0\.|
|rtx.autoExposure.exposureWeightCurve1|float|1|Curve control point 1\.|
|rtx.autoExposure.exposureWeightCurve2|float|1|Curve control point 2\.|
|rtx.autoExposure.exposureWeightCurve3|float|1|Curve control point 3\.|
|rtx.autoExposure.exposureWeightCurve4|float|1|Curve control point 4\.|
|rtx.autoExposure.useExposureCompensation|bool|False|Uses a curve to determine the importance of different exposure levels when calculating average exposure\.|
|rtx.automation.disableBlockingDialogBoxes|bool|False|Disables various blocking blocking dialog boxes \(such as popup windows\) requiring user interaction when set to true, otherwise uses default behavior when set to false\.<br>This option is typically meant for automation\-driven execution of Remix where such dialog boxes if present may cause the application to hang due to blocking waiting for user input\.|
|rtx.automation.disableDisplayMemoryStatistics|bool|False|Disables display of memory statistics in the Remix window\.<br>This option is typically meant for automation of tests for which we don't want non\-deterministic runtime memory statistics to be shown in GUI that is included as part of test image output\.|
|rtx.automation.disableUpdateUpscaleFromDlssPreset|bool|False|Disables updating upscaler from DLSS preset\.<br>This option is typically meant for automation of tests for which we don't want upscaler to be updated based on a DLSS preset\.|
|rtx.automation.suppressAssetLoadingErrors|bool|False|Suppresses asset loading errors by turning them into warnings\.<br>This option is typically meant for automation of tests for which acceptable asset loading issues are known\.|
|rtx.blockInputToGameInUI|bool|True||
|rtx.bloom.burnIntensity|float|1|Amount of bloom to add to the final image\.|
|rtx.bloom.enable|bool|True|Enable bloom \- glowing halos around intense, bright areas\.|
|rtx.bloom.luminanceThreshold|float|0.25|Adjust the bloom threshold to suppress blooming of the dim areas\. Pixels with luminance lower than the threshold are multiplied by the weight value that smoothly transitions from 1\.0 \(at luminance=threshold\) to 0\.0 \(at luminance=0\)\.|
|rtx.calculateLightIntensityUsingLeastSquares|bool|True|Enable usage of least squares for approximating a light's falloff curve rather than a more basic single point approach\. This will generally result in more accurate matching of the original application's custom light attenuation curves, especially with non physically based linear\-style attenuation\.|
|rtx.camera.enableFreeCamera|bool|False|Enables free camera\.|
|rtx.camera.freeCameraPitch|float|0|Free camera's pitch\.|
|rtx.camera.freeCameraPosition|float3|0, 0, 0|Free camera's position\.|
|rtx.camera.freeCameraViewRelative|bool|True|Free camera transform is relative to the view\.|
|rtx.camera.freeCameraYaw|float|0|Free camera's position\.|
|rtx.camera.lockFreeCamera|bool|False|Locks free camera\.|
|rtx.cameraAnimationAmplitude|float|2|Amplitude of the free camera's animation\.|
|rtx.cameraAnimationMode|int|3|Free camera's animation mode\.|
|rtx.cameraJitterSequenceLength|int|64|Sets a camera jitter sequence length \[number of frames\]\. It will loop around once the length is reached\.|
|rtx.cameraSequence.autoLoad|bool|False|Load camera sequence automatically\.|
|rtx.cameraSequence.currentFrame|int|0|Current Frame\.|
|rtx.cameraSequence.mode|int|0|Current mode\.|
|rtx.cameraShakePeriod|int|20|Period of the free camera's animation\.|
|rtx.capture.correctBakedTransforms|bool|False|Some games bake world transforms into mesh vertices\. If individually captured<br>meshes appear to be way off in the middle of nowhere OR instanced meshes appear<br>to all have identity xform matrices, enabling will attempt to correct this and<br>improve stage \+ mesh viewability in tools\.<br>Hashes are unaffected\.|
|rtx.captureDebugImage|bool|False||
|rtx.captureEnableMultiframe|bool|False|Enables multi\-frame capturing\. THIS HAS NOT BEEN MAINTAINED AND SHOULD BE USED WITH EXTREME CAUTION\.|
|rtx.captureFramesPerSecond|int|24|Playback rate marked in the USD stage\.<br>Will eventually determine frequency with which game state is captured and written\. Currently every frame \-\- even those at higher frame rates \-\- are recorded\.|
|rtx.captureHotKey|unknown type|unknown type|Hotkey to trigger a capture without bringing up the menu\.<br>example override: 'rtx\.captureHotKey = CTRL, SHIFT, P'<br>Full list of key names available in src/util/util\_keybind\.h|
|rtx.captureInstances|bool|True|If true, an instanced snapshot of the game scene will be captured and exported to a USD stage, in addition to all meshes, textures, materials, etc\.<br>If false, only meshes, etc will be captured\.|
|rtx.captureMaxFrames|int|1|Max frames capturable when running a multi\-frame capture\. The capture can be toggled to completion manually\.|
|rtx.captureMeshBlendWeightDelta|float|0.01|Inter\-frame blend weight min delta warrants new time sample\.|
|rtx.captureMeshColorDelta|float|0.3|Inter\-frame color min delta warrants new time sample\.|
|rtx.captureMeshNormalDelta|float|0.3|Inter\-frame normal min delta warrants new time sample\.|
|rtx.captureMeshPositionDelta|float|0.3|Inter\-frame position min delta warrants new time sample\.|
|rtx.captureMeshTexcoordDelta|float|0.3|Inter\-frame texcoord min delta warrants new time sample\.|
|rtx.captureNoInstance|bool|False|Same as 'rtx\.captureInstances' except inverse\. This is the original/old variant, and will be deprecated, however is still functional\.|
|rtx.captureShowMenuOnHotkey|bool|True|If true, then the capture menu will appear whenever one of the capture hotkeys are pressed\. A capture MUST be started by using a button in the menu, in that case\.<br>If false, the hotkeys behave as expected\. The user must manually open the menu in order to change any values\.|
|rtx.compositePrimaryDirectDiffuse|bool|True|Enables direct lightning's diffuse signal for primary surfaces in the final composite\.|
|rtx.compositePrimaryDirectSpecular|bool|True|Enables direct lightning's specular signal for primary surfaces in the final composite\.|
|rtx.compositePrimaryIndirectDiffuse|bool|True|Enables indirect lightning's diffuse signal for primary surfaces in the final composite\.|
|rtx.compositePrimaryIndirectSpecular|bool|True|Enables indirect lightning's specular signal for primary surfaces in the final composite\.|
|rtx.compositeSecondaryCombinedDiffuse|bool|True|Enables combined direct and indirect lightning's diffuse signal for secondary surfaces in the final composite\.|
|rtx.compositeSecondaryCombinedSpecular|bool|True|Enables combined direct and indirect lightning's specular signal for secondary surfaces in the final composite\.|
|rtx.debugView.composite.compositeViewIdx|int|0|Index of a composite view to show when Composite Debug View is enabled\. The index must be a a valid value from CompositeDebugView enumeration\. Value of 0 disables Composite Debug View\.|
|rtx.debugView.debugViewIdx|int|0|Index of a debug view to show when Debug View is enabled\. The index must be a valid value from DEBUG\_VIEW\_\* macro defined indices\. Value of 0 disables Debug View\.|
|rtx.debugView.displayType|int|0|The display type to use for visualizing debug view input values\.<br>Supported display types are: 0 = Standard, 1 = BGR Exclusive Color, 2 = EV100, 3 = HDR Waveform<br>Each mode may be useful for a different kind of visualization, though Standard is typically the most common mode to use\.<br>Standard mode works for a simple direct, scaled or color mapped visualization, BGR exclusive for another type of color mapped visualization, and EV100 or the HDR Waveform for understanding HDR value magnitudes in the input on a log scale\.|
|rtx.debugView.enableAccumulation|bool|False|Enables accumulation of debug ouptput's result to emulate multiple samples per pixel or over time\.|
|rtx.debugView.enableContinuousAccumulation|bool|True|Enables continuous accumulation even after numberOfFramesToAccumulate frame count is reached\.<br>Frame to frame accumulation weight remains limitted by numberOfFramesToAccumulate count\.<br>This, however, skews the result as values contribute to the end result longer than numberOfFramesToAccumulate allows\.<br>|
|rtx.debugView.enableFp16Accumulation|bool|False|Accumulate using fp16 precision\. Default is fp32\.<br>Much of the renderer is limitted to fp16 formats so on one hand fp16 better emulates renderer's formats\.<br>On the other hand, renderer also clamps and filters the signal in many places and thus is less prone<br>from very high values causing precision issues preventing very low values have any impact\.<br>Therefore, to minimize precision issues the default accumulation mode is set to fp32\.|
|rtx.debugView.enableGammaCorrection|bool|False|Enables gamma correction of a debug view value\.|
|rtx.debugView.enableInputQuantization|bool|False|Enables uniform\-step input quantization on debug view input buffers\.<br>This is mostly useful for when debugging artifacts relating to quantization that may not be visible in a buffer due to higher precision formats in use\.<br>For example, the final output from tonemapping is a floating point texture in the debug view but will be quantized to 8 bit on some monitors\. Using this option the quantization which will be applied to the output can be visualized in advance\.|
|rtx.debugView.evMaxValue|int|4|The maximum EV100 debug view input value to map to the top of the visualization range when EV100 debug display is in use\. Values above this value in the input will be clamped to the top of the range\.|
|rtx.debugView.evMinValue|int|-4|The minimum EV100 debug view input value to map to the bottom of the visualization range when EV100 debug display is in use\. Values below this value in the input will be clamped to the bottom of the range\.|
|rtx.debugView.gpuPrint.enable|bool|False|Enables writing into a GPU buffer that's read by CPU when CTRL is pressed\. The value is printed to console\.|
|rtx.debugView.gpuPrint.pixelIndex|int2|2147483647, 2147483647|Pixel position to GPU print for\. Requires useMousePosition to be turned off\.|
|rtx.debugView.gpuPrint.useMousePosition|bool|True|Uses mouse position to select a pixel to GPU print for\.|
|rtx.debugView.inverseQuantizationStepSize|float|255|The inverse of the uniform step size to quantize the debug view input to when Input Quantization is enabled\.<br>A value of 255 indicates that the input will be quantized to steps of 1/255, the same as the step size used when quantizing the range 0\-1 to an 8 bit representation\.|
|rtx.debugView.maxValue|float|1|The maximum debug view input value to map to 1 in the output when the standard debug display is in use\. Values above this value in the input will be clamped to 1 in the output\.|
|rtx.debugView.minValue|float|0|The minimum debug view input value to map to 0 in the output when the standard debug display is in use\. Values below this value in the input will be clamped to 0 in the output\.|
|rtx.debugView.numberOfFramesToAccumulate|int|1024|Number of frames to accumulate debug view's result over\.<br>This can be used for generating reference images smoothed over time\.<br>By default the accumulation stops once the limit is reached\.<br>When desired, continous accumulation can be enabled via enableContinuousAccumulation\.|
|rtx.debugView.pseudoColorMode|int|0|Selects a mode for mapping debug value inputs to a scalar to be visualized using a colormap spectrum\. Only takes effect when rtx\.debugView\.displayType is set to "Standard"\.<br>Supported modes are: 0 = Disabled, 1 = Luminance, 2 = Red, 3 = Green, 4 = Blue, 5 = Alpha\.<br>Useful for visualizing a value's range with greater precision than a simple monochromatic color spectrum \(due to interpolating across an entire spectrum of color with a roughly uniform progression\)\.|
|rtx.debugView.replaceCompositeOutput|bool|False|Replaces composite output with debug view output that is generated right after composition pass\.<br>Allows for debug view output to get the post composition pipeline applied to it, such as upscaling and postprocessing actions\)\.<br>Note any Debug Views having data set post Composite pass require this setting to be disabled to work\.<br>When disabled Debug View output is generated close to the end of RTX pipeline \(after postprocessing and upscaling\)\.|
|rtx.debugView.samplerType|int|2|Sampler type for debug views that sample from a texture \(applies only to a subset of debug views\)\.<br>Supported types are: 0 = Nearest, 1 = Normalized Nearest, 2 = Normalized Linear|
|rtx.debugView.showFirstGBufferHit|bool|False|Show information of the first hit surface\.<br>|
|rtx.defaultToAdvancedUI|bool|False||
|rtx.demodulate.demodulateRoughness|bool|True|Demodulate roughness to improve specular details\.|
|rtx.demodulate.demodulateRoughnessOffset|float|0.1|Strength of roughness demodulation, lower values are stronger\.|
|rtx.demodulate.directLightBoilingThreshold|float|5|Remove direct light sample when its luminance is higher than the average one multiplied by this threshold \.|
|rtx.demodulate.enableDirectLightBoilingFilter|bool|True|Boiling filter removing direct light sample when its luminance is too high\.|
|rtx.denoiseDirectAndIndirectLightingSeparately|bool|True|Denoising quality, high uses separate denoising of direct and indirect lighting for higher quality at the cost of performance\.|
|rtx.denoiser.maxDirectHitTContribution|float|-1||
|rtx.denoiser.nrd.timeDeltaBetweenFrames|float|0|Frame time in milliseconds to use for denoising\. Setting this to 0 will use actual frame time for a given frame\. Non\-zero value is primarily used for automation to ensure image output determinism\.|
|rtx.denoiserIndirectMode|int|14||
|rtx.denoiserMode|int|14||
|rtx.di.confidenceGradientPower|float|8||
|rtx.di.confidenceGradientScale|float|6||
|rtx.di.confidenceHistoryLength|float|8||
|rtx.di.confidenceHitDistanceSensitivity|float|300||
|rtx.di.disocclusionFrames|int|8||
|rtx.di.disocclusionSamples|int|4|The number of spatial reuse samples in disocclusion areas\.|
|rtx.di.enableBestLightSampling|bool|True|Whether to include a single best light from the previous frame's pixel neighborhood into initial sampling\.|
|rtx.di.enableCrossPortalLight|bool|True||
|rtx.di.enableDenoiserConfidence|bool|True||
|rtx.di.enableDenoiserGradient|bool|True|Enable gradient calculation, which is used by confidence calculation and GI sample validation\.|
|rtx.di.enableDiscardEnlargedPixels|bool|True||
|rtx.di.enableDiscardInvisibleSamples|bool|True|Whether to discard reservoirs that are determined to be invisible in final shading\.|
|rtx.di.enableInitialVisibility|bool|True|Whether to trace a visibility ray for the light sample selected in the initial sampling pass\.|
|rtx.di.enableRayTracedBiasCorrection|bool|True|Whether to use ray traced bias correction in the spatial reuse pass\.|
|rtx.di.enableSampleStealing|bool|True|No visibile IQ gains, but exhibits considerable perf drop \(8% in integrate pass\)\.|
|rtx.di.enableSpatialReuse|bool|True|Whether to apply spatial reuse\.|
|rtx.di.enableTemporalBiasCorrection|bool|True||
|rtx.di.enableTemporalReuse|bool|True|Whether to apply temporal reuse\.|
|rtx.di.gradientFilterPasses|int|4||
|rtx.di.gradientHitDistanceSensitivity|float|10||
|rtx.di.initialSampleCount|int|4|The number of lights randomly selected from the global pool to consider when selecting a light with RTXDI\.|
|rtx.di.maxHistoryLength|int|4|Maximum age of reservoirs for temporal reuse\.|
|rtx.di.minimumConfidence|float|0.1||
|rtx.di.permutationSamplingNthFrame|int|0|Apply permutation sampling when \(frameIdx % this == 0\), 0 means off\.|
|rtx.di.spatialSamples|int|2|The number of spatial reuse samples in converged areas\.|
|rtx.di.stealBoundaryPixelSamplesWhenOutsideOfScreen|bool|True|Steal screen boundary samples when a hit point is outside the screen\.|
|rtx.displacement.displacementFactor|float|1|Scaling factor for all displacement maps|
|rtx.displacement.enableDirectLighting|bool|True|Whether direct lighting accounts for displacement mapping|
|rtx.displacement.enableIndirectHit|bool|False|Whether indirect ray hits account for displacement mapping \(Enabling this is expensive\.  Without it, non\-perfect reflections of displaced objects will not show displacement\.\)|
|rtx.displacement.enableIndirectLighting|bool|True|Whether indirect lighting accounts for displacement mapping|
|rtx.displacement.enableNEECache|bool|True|Whether the NEE cache accounts for displacement mapping|
|rtx.displacement.enablePSR|bool|False|Enable PSR \(perfect reflections\) for materials with displacement\.  Rays that have been perfectly reflected off a POM surface will not collide correctly with other parts of that same surface\.|
|rtx.displacement.enableReSTIRGI|bool|True|Whether ReSTIR GI accounts for displacement mapping|
|rtx.displacement.maxIterations|int|64|The max number of times the POM raymarch will iterate\.|
|rtx.displacement.mode|int|2|What algorithm the displacement uses\.<br>RaymarchPOM: advances the ray in linear steps until the ray is below the heightfield\.<br>QuadtreePOM: Relies on special mipmaps with maximum values instead of average values\.  Uses the mipmap as a quadtree\.|
|rtx.dlfg.enable|bool|True|Enables DLSS 3\.0 frame generation which generates interpolated frames to increase framerate at the cost of slightly more latency\.|
|rtx.dlfg.enablePresentMetering|bool|True|Use hardware present metering for DLSS 4\.0 frame generation instead of CPU pacing\.|
|rtx.dlfg.maxInterpolatedFrames|int|2|For DLSS 4\.0 frame generation, controls the number of interpolated frames for each rendered frame\. Ignored for DLSS 3\.0\.|
|rtx.dlssEnhancementDirectLightMaxValue|float|10|The maximum strength of direct lighting enhancement\.|
|rtx.dlssEnhancementDirectLightPower|float|0.7|The overall strength of direct lighting enhancement\.|
|rtx.dlssEnhancementIndirectLightMaxValue|float|1.5|The maximum strength of indirect lighting enhancement\.|
|rtx.dlssEnhancementIndirectLightMinRoughness|float|0.3|The reference roughness in indirect lighting enhancement\.|
|rtx.dlssEnhancementIndirectLightPower|float|1|The overall strength of indirect lighting enhancement\.|
|rtx.dlssEnhancementMode|int|1|The enhancement filter type\. Valid values: \<Normal Difference=1, Laplacian=0\>\. Normal difference mode provides more normal detail at the cost of some noise\. Laplacian mode is less aggressive\.|
|rtx.dlssPreset|int|1|Combined DLSS Preset for quickly controlling Upscaling, Frame Interpolation and Latency Reduction\.|
|rtx.drawCallRange|int2|0, 2147483647||
|rtx.dust.anisotropy|float|0.5|Anisotropy of the particles for lighting purposes\.|
|rtx.dust.enable|bool|False|Enables dust particle simulation and rendering\.|
|rtx.dust.gravityForce|float|-0.5|Net influence of gravity acting on each particle \(meters per second squared\)\.|
|rtx.dust.maxParticleLife|float|6|Maximum lifetime \(in seconds\) to give to a particle when spawned\.|
|rtx.dust.maxParticleSize|float|3|Maximum size \(in pixels\) to give to a particle when spawned\.|
|rtx.dust.maxSpawnDistance|float|400|Maximum distance in world space from camera to spawn particles\.|
|rtx.dust.maxSpeed|float|3|Maximum speed of a particle in world space\.|
|rtx.dust.minParticleLife|float|3|Minimum lifetime \(in seconds\) to give to a particle when spawned\.|
|rtx.dust.minParticleSize|float|1|Minimum size \(in pixels\) to give to a particle when spawned\.|
|rtx.dust.minSpawnDistance|float|20|Minimum distance in world space from camera to spawn particles\.|
|rtx.dust.numberOfParticles|int|1000000|Maximum number of particles to simulate simultaneously\.|
|rtx.dust.opacity|float|0.5|Opacity of the particles\.|
|rtx.dust.rotationSpeed|float|5|How quickly the particle is rotating \(this primarily only affects light interaction\)\.|
|rtx.dust.timeScale|float|1|Time modifier, can be used to slow/speed up time\.|
|rtx.dust.turbulenceAmplitude|float|5|How much turbulence influences the force of a particle\.|
|rtx.dust.turbulenceFrequency|float|0.05|The rate of change of turbulence forces\.|
|rtx.dust.useTurbulence|bool|True|Enable turbulence simulation\.|
|rtx.effectLightColor|float3|1, 1, 1|Colour of the effect light, if not using plasma ball mode\.  Effect lights can be attached to materials from the remix runtime menu, using the \`Add Light to Texture\` texture tag in game setup\.|
|rtx.effectLightIntensity|float|1|The intensity of the effect light\.  Effect lights can be attached to materials from the remix runtime menu, using the \`Add Light to Texture\` texture tag in game setup\.|
|rtx.effectLightPlasmaBall|bool|False|Use plasma ball mode, in this mode the effect light color is ignored\.  Effect lights can be attached to materials from the remix runtime menu, using the \`Add Light to Texture\` texture tag in game setup\.|
|rtx.effectLightRadius|float|5|The sphere radius of the effect light\.  Effect lights can be attached to materials from the remix runtime menu, using the \`Add Light to Texture\` texture tag in game setup\.|
|rtx.emissiveBlendOverrideEmissiveIntensity|float|0.2|The emissive intensity to use when the emissive blend override is enabled\. Adjust this if particles for example look overly bright globally\.|
|rtx.emissiveIntensity|float|1|A general scale factor on all emissive intensity values globally\. Generally per\-material emissive intensities should be used, but this option may be useful for debugging without needing to author materials\.|
|rtx.enableAlphaBlend|bool|True|Enable rendering alpha blended geometry, used for partial opacity and other blending effects on various surfaces in many games\.|
|rtx.enableAlphaTest|bool|True|Enable rendering alpha tested geometry, used for cutout style opacity in some games\.|
|rtx.enableAlwaysCalculateAABB|bool|False|Calculate an Axis Aligned Bounding Box for every draw call\.<br> This may improve instance tracking across frames for skinned and vertex shaded calls\.|
|rtx.enableBillboardOrientationCorrection|bool|True||
|rtx.enableBreakIntoDebuggerOnPressingB|bool|False|Enables a break into a debugger at the start of InjectRTX\(\) on a press of key 'B'\.<br>If debugger is not attached at the time, it will wait until a debugger is attached and break into it then\.|
|rtx.enableCulling|bool|True|Enable front/backface culling for opaque objects\. Objects with alpha blend or alpha test are not culled\.|
|rtx.enableCullingInSecondaryRays|bool|False|Enable front/backface culling for opaque objects\. Objects with alpha blend or alpha test are not culled\.  Only applies in secondary rays, defaults to off\.  Generally helps with light bleeding from objects that aren't watertight\.|
|rtx.enableDLSSEnhancement|bool|True|Enhances lighting details when DLSS is on\.|
|rtx.enableDecalMaterialBlending|bool|True|A flag to enable or disable material blending on decals\.<br>This should generally always be enabled when decals are in use as this allows decals to be blended down on to the surface they sit slightly above which results in more convincing decals rendering\.|
|rtx.enableDirectAlphaBlendShadows|bool|True|Calculate shadows for semi\-transparent materials \(alpha blended\) in direct lighting\. In engineering terms: include OBJECT\_MASK\_ALPHA\_BLEND into primary visibility rays\.|
|rtx.enableDirectLighting|bool|True|Enables direct lighting \(lighting directly from lights on to a surface\) on surfaces when set to true, otherwise disables it\.|
|rtx.enableDirectTranslucentShadows|bool|False|Calculate coloured shadows for translucent materials \(i\.e\. glass, water\) in direct lighting\. In engineering terms: include OBJECT\_MASK\_TRANSLUCENT into primary visibility rays\.|
|rtx.enableEmissiveBlendEmissiveOverride|bool|True|Override typical material emissive information on draw calls with any emissive blending modes to emulate their original look more accurately\.|
|rtx.enableEmissiveBlendModeTranslation|bool|True|Treat incoming semi/additive D3D blend modes as emissive\.|
|rtx.enableFallbackLightShaping|bool|False|Enables light shaping on the fallback light \(only used for non\-Distant light types\)\.|
|rtx.enableFallbackLightViewPrimaryAxis|bool|False|Enables usage of the camera's view axis as the primary axis for the fallback light's shaping \(only used for non \- Distant light types\)\. Typically the shaping primary axis may be specified directly, but if desired it may be set to the camera's view axis for a "flashlight" effect\.|
|rtx.enableFirstBounceLobeProbabilityDithering|bool|True|A flag to enable or disable screen\-space probability dithering on the first indirect lobe sampled\.<br>Generally sampling a diffuse, specular or other lobe relies on a random number generated against the probability of sampling each lobe, effectively focusing more rays/paths on lobes which matter more\.<br>This can cause issues however with denoisers which do not handle sparse stochastic signals \(like those from path tracing\) well as they may be expecting a more "complete" signal like those used in simpler branching ray tracing setups\.<br>To help solve this issue this option uses a temporal screenspace dithering based on the probability rather than a purely random choice to determine which lobe to sample from on the first indirect bounce\.<br>This as a result helps ensure there will always be a diffuse or specular sample within the dithering pattern's area and should help the denoising resolve a more stable result\.|
|rtx.enableFog|bool|True||
|rtx.enableIndexBufferMemoization|bool|True|CPU performance optimization, should generally be enabled\.  Will reduce main thread time by caching processIndexBuffer operations and reusing when possible, this will come at the expense of some CPU RAM\.|
|rtx.enableIndirectAlphaBlendShadows|bool|True|Calculate shadows for semi\-transparent \(alpha blended\) objects in indirect lighting \(i\.e\. reflections and GI\)\. In engineering terms: include OBJECT\_MASK\_ALPHA\_BLEND into secondary visibility rays\.|
|rtx.enableIndirectTranslucentShadows|bool|False|Calculate coloured shadows for translucent materials \(i\.e\. glass, water\) in indirect lighting \(i\.e\. reflections and GI\)\. In engineering terms: include OBJECT\_MASK\_TRANSLUCENT into secondary visibility rays\.|
|rtx.enableInstanceDebuggingTools|bool|False|NOTE: This will disable temporal correllation for instances, but allow the use of instance developer debug tools|
|rtx.enableMultiStageTextureFactorBlending|bool|True|Support texture factor blending in stage 1~7\. Currently only support 1 additional blending stage, more than 1 additional blending stages will be ignored\.|
|rtx.enableNearPlaneOverride|bool|False|A flag to enable or disable the Camera's near plane override feature\.<br>Since the camera is not used directly for ray tracing the near plane the application uses typically does not matter, but for certain matrix\-based operations \(such as temporal reprojection or voxel grid projection\) it is still relevant\.<br>The issue arises when geometry is ray traced that is behind where the chosen Camera's near plane is located, typically common on viewmodels especially with how they are ray traced, causing graphical artifacts and other issues\.<br>This option helps correct this issue by overriding the near plane value to else \(usually smaller\) to sit behind the objects in question \(such as the view model\)\. As such this option should usually be enabled on games with viewmodels\.<br>Do note that when adjusting the near plane the larger the relative magnitude gap between the near and far plane the worse the precision of matrix operations will be, so the near plane should be set as high as possible even when overriding\.|
|rtx.enablePSRR|bool|True|A flag to enable or disable reflection PSR \(Primary Surface Replacement\)\.<br>When enabled this feature allows higher quality mirror\-like reflections in special cases by replacing the G\-Buffer's surface with the reflected surface\.<br>Should usually be enabled for the sake of quality as almost all applications will utilize it in the form of glass or mirrors\.|
|rtx.enablePSTR|bool|True|A flag to enable or disable transmission PSR \(Primary Surface Replacement\)\.<br>When enabled this feature allows higher quality glass\-like refraction in special cases by replacing the G\-Buffer's surface with the refracted surface\.<br>Should usually be enabled for the sake of quality as almost all applications will utilize it in the form of glass\.|
|rtx.enablePSTROutgoingSplitApproximation|bool|True|Enable transmission PSR on outgoing transmission events such as leaving translucent materials \(rather than respecting no\-split path PSR rule\)\.<br>Typically this results in better looking glass when enabled \(at the cost of accuracy due to ignoring non\-TIR inter\-reflections within the glass itself\)\.|
|rtx.enablePSTRSecondaryIncidentSplitApproximation|bool|True|Enable transmission PSR on secondary incident transmission events such as entering a translucent material on an already\-transmitted path \(rather than respecting no\-split path PSR rule\)\.<br>Typically this results in better looking glass when enabled \(at the cost accuracy due to ignoring reflections off of glass seen through glass for example\)\.|
|rtx.enablePortalFadeInEffect|bool|False||
|rtx.enablePresentThrottle|bool|False|A flag to enable or disable present throttling, when set to true a sleep for a time specified by the throttle delay will be inserted into the DXVK presentation thread\.<br>Useful to manually reduce the framerate if the application is running too fast or to reduce GPU power usage during development to keep temperatures down\.<br>Should not be enabled in anything other than development situations\.|
|rtx.enableProbabilisticUnorderedResolveInIndirectRays|bool|True|A flag to enable or disable probabilistic unordered resolve approximations in indirect rays\.<br>This flag speeds up the unordered resolve for indirect rays by probabilistically deciding when to perform unordered resolve or not\.  Must have both unordered resolve and unordered resolve in indirect rays enabled for this to take effect\.<br>This option should be enabled by default as it can significantly improve performance on some hardware\.  In rare cases it may come at the cost of some quality for particles and decals in reflections\.<br>Note that even with this option enabled, unordered resolve approximations are only done on the first indirect bounce for the sake of performance overall\.|
|rtx.enableRayReconstruction|bool|True|Enable ray reconstruction\.|
|rtx.enableRaytracing|bool|True|Globally enables or disables ray tracing\. When set to false the original game should render mostly as it would in DXVK typically\.<br>Some artifacts may still appear however compared to the original game either due to issues with the underlying DXVK translation or issues in Remix itself\.|
|rtx.enableReplacementAssets|bool|True|Globally enables or disables all enhanced asset replacement \(materials, meshes, lights\) functionality\.|
|rtx.enableReplacementInstancerMeshRendering|bool|True|Enables or disables rendering GeomPointInstancer meshes using an optimized path\.<br>Requires reloading replacement assets\.|
|rtx.enableReplacementLights|bool|True|Enables or disables enhanced light replacements\.<br>Requires replacement assets in general to be enabled to have any effect\.|
|rtx.enableReplacementMaterials|bool|True|Enables or disables enhanced material replacements\.<br>Requires replacement assets in general to be enabled to have any effect\.|
|rtx.enableReplacementMeshes|bool|True|Enables or disables enhanced mesh replacements\.<br>Requires replacement assets in general to be enabled to have any effect\.|
|rtx.enableRussianRoulette|bool|True|A flag to enable or disable Russian Roulette, a rendering technique to give paths a chance of terminating randomly with each bounce based on their importance\.<br>This is usually useful to have enabled as it will ensure useless paths are terminated earlier while more important paths are allowed to accumulate more bounces\.<br>Furthermore this allows for the renderer to remain unbiased whereas a hard clamp on the number of bounces will introduce bias \(though this is also done in Remix for the sake of performance\)\.<br>On the other hand, randomly terminating paths too aggressively may leave threads in GPU warps without work which may hurt thread occupancy when not used with a thread\-reordering technique like SER\.|
|rtx.enableSecondaryBounces|bool|True|Enables indirect lighting \(lighting from diffuse/specular bounces to one or more other surfaces\) on surfaces when set to true, otherwise disables it\.|
|rtx.enableSeparateUnorderedApproximations|bool|True|Use a separate loop during resolving for surfaces which can have lighting evaluated in an approximate unordered way on each path segment \(such as particles\)\.<br>This improves performance typically in how particles or decals are rendered and should usually always be enabled\.<br>Do note however the unordered nature of this resolving method may result in visual artifacts with large numbers of stacked particles due to difficulty in determining the intended order\.<br>Additionally, unordered approximations will only be done on the first indirect ray bounce \(as particles matter less in higher bounces\), and only if enabled by its corresponding setting\.|
|rtx.enableShaderExecutionReorderingInPathtracerGbuffer|bool|False|\(Note: Hard disabled in shader code\) Enables Shader Execution Reordering \(SER\) in GBuffer Raytrace pass if SER is supported\.|
|rtx.enableShaderExecutionReorderingInPathtracerIntegrateIndirect|bool|True|Enables Shader Execution Reordering \(SER\) in Integrate Indirect pass if SER is supported\.|
|rtx.enableStochasticAlphaBlend|bool|True|Use stochastic alpha blend\.|
|rtx.enableTransmissionApproximationInIndirectRays|bool|False|A flag to enable transmission approximations in indirect rays\.<br>Translucent objects hit by indirect rays will not alter ray direction, just change the ray throughput\.|
|rtx.enableUnorderedEmissiveParticlesInIndirectRays|bool|False|A flag to enable or disable unordered resolve emissive particles specifically in indirect rays\.<br>Should be enabled in higher quality rendering modes as emissive particles are fairly important in reflections, but may be disabled to skip such interactions which can improve performance on lower end hardware\.<br>Note that rtx\.enableUnorderedResolveInIndirectRays must first be enabled for this option to take any effect \(as it will control if unordered resolve is used to begin with in indirect rays\)\.|
|rtx.enableUnorderedResolveInIndirectRays|bool|True|A flag to enable or disable unordered resolve approximations in indirect rays\.<br>This allows for the presence of unordered approximations in resolving to be overridden in indirect rays and as such requires separate unordered approximations to be enabled to have any effect\.<br>This option should be enabled if objects which can be resolvered in an unordered way in indirect rays are expected for higher quality in reflections, but may come at a performance cost\.<br>Note that even with this option enabled, unordered resolve approximations are only done on the first indirect bounce for the sake of performance overall\.|
|rtx.enableVsync|int|2|Controls the game's V\-Sync setting\. Native game's V\-Sync settings are ignored\.|
|rtx.fallbackLightAngle|float|5|The angular size in degrees to use for the fallback light \(used only for Distant light types\)\. Should only be within the range \[0, 180\]\.|
|rtx.fallbackLightConeAngle|float|25|The cone angle in degrees to use for the fallback light shaping \(used only for non\-Distant light types with shaping enabled\)\. Should only be within the range \[0, 180\]\.|
|rtx.fallbackLightConeSoftness|float|0.1|The cone softness to use for the fallback light shaping \(used only for non\-Distant light types with shaping enabled\)\.|
|rtx.fallbackLightDirection|float3|-0.2, -1, 0.4|The direction to use for the fallback light \(used only for Distant light types\)|
|rtx.fallbackLightFocusExponent|float|2|The focus exponent to use for the fallback light shaping \(used only for non\-Distant light types with shaping enabled\)\.|
|rtx.fallbackLightMode|int|1|The mode to determine when to create a fallback light\.<br>Never \(0\) never creates the light, NoLightsPresent \(1\) creates the fallback light only when no lights are provided to Remix, and Always \(2\) always creates the fallback light\.<br>Primarily a debugging feature, users should create their own lights via the Remix workflow rather than relying on this feature to provide lighting\.<br>As such, this option should be set to Never for "production" builds of Remix creations to avoid the fallback light from appearing in games unintentionally in cases where no lights exist \(which is the default behavior when set to NoLightsPresent\)\.|
|rtx.fallbackLightPositionOffset|float3|0, 0, 0|The position offset from the camera origin to use for the fallback light \(used only for non\-Distant light types\)\.|
|rtx.fallbackLightPrimaryAxis|float3|0, 0, -1|The primary axis to use for the fallback light shaping \(used only for non\-Distant light types\)\.|
|rtx.fallbackLightRadiance|float3|1.6, 1.8, 2|The radiance to use for the fallback light \(used across all light types\)\.|
|rtx.fallbackLightRadius|float|5|The radius to use for the fallback light \(used only for Sphere light types\)\.|
|rtx.fallbackLightType|int|0|The light type to use for the fallback light\. Determines which other fallback light options are used\.|
|rtx.fireflyFilteringLuminanceThreshold|float|1000|Maximum luminance threshold for the firefly filtering to clamp to\.|
|rtx.fogColorScale|float|0.25||
|rtx.fogIgnoreSky|bool|False|If true, sky draw calls will be skipped when searching for the D3D9 fog values\.|
|rtx.forceCameraJitter|bool|False|Force enables camera jitter frame to frame\.|
|rtx.forceCutoutAlpha|float|0.5|When an object is added to the cutout textures list it will have a cutout alpha mode forced on it, using this value for the alpha test\.<br>This is meant to improve the look of some legacy mode materials using low\-resolution textures and alpha blending instead of alpha cutout as this can cause blurry halos around edges due to the difficulty of handling this sort of blending in Remix\.<br>Such objects are generally better handled with actual replacement assets using fully opaque geometry replacements or alpha cutout with higher resolution textures, so this should only be relied on until proper replacements can be authored\.|
|rtx.forceMergeAllMeshes|bool|False|Force merges all meshes into as few BLAS as possible\.  This is generally not desirable for performance, but can be a useful debugging tool\.|
|rtx.freeCam.keyMoveBack|unknown type|unknown type|Move back in free camera mode\.<br>Example override: 'rtx\.rtx\.freeCam\.keyMoveBack = P'|
|rtx.freeCam.keyMoveDown|unknown type|unknown type|Move down in free camera mode\.<br>Example override: 'rtx\.rtx\.freeCam\.keyMoveDown = P'|
|rtx.freeCam.keyMoveFaster|unknown type|unknown type|Move faster in free camera mode\.<br>Example override: 'rtx\.rtx\.freeCam\.keyMoveForward = RSHIFT'|
|rtx.freeCam.keyMoveForward|unknown type|unknown type|Move forward in free camera mode\.<br>Example override: 'rtx\.rtx\.freeCam\.keyMoveForward = P'|
|rtx.freeCam.keyMoveLeft|unknown type|unknown type|Move left in free camera mode\.<br>Example override: 'rtx\.rtx\.freeCam\.keyMoveLeft = P'|
|rtx.freeCam.keyMoveRight|unknown type|unknown type|Move right in free camera mode\.<br>Example override: 'rtx\.rtx\.freeCam\.keyMoveRight = P'|
|rtx.freeCam.keyMoveUp|unknown type|unknown type|Move up in free camera mode\.<br>Example override: 'rtx\.rtx\.freeCam\.keyMoveUp = P'|
|rtx.freeCam.keyPitchDown|unknown type|unknown type|Pitch down in free camera mode\.<br>Example override: 'rtx\.rtx\.freeCam\.keyPitchDown = P'|
|rtx.freeCam.keyPitchUp|unknown type|unknown type|Pitch up in free camera mode\.<br>Example override: 'rtx\.rtx\.freeCam\.keyPitchUp = P'|
|rtx.freeCam.keyYawLeft|unknown type|unknown type|Yaw left in free camera mode\.<br>Example override: 'rtx\.rtx\.freeCam\.keyYawLeft = P'|
|rtx.freeCam.keyYawRight|unknown type|unknown type|Yaw right in free camera mode\.<br>Example override: 'rtx\.rtx\.freeCam\.keyYawRight = P'|
|rtx.freeCameraInvertY|bool|False|Invert free camera pitch direction\.|
|rtx.freeCameraSpeed|float|200|Free camera speed \[GameUnits/s\]\.|
|rtx.freeCameraTurningSpeed|float|1|Free camera turning speed \(applies to keyboard, not mouse\) \[radians/s\]\.|
|rtx.fusedWorldViewMode|int|0|Set if game uses a fused World\-View transform matrix\.|
|rtx.graphicsPreset|int|5|Overall rendering preset, higher presets result in higher image quality, lower presets result in better performance\.|
|rtx.gui.hudMessageAnimatedDotDurationMilliseconds|int|1000|A duration in milliseconds between each dot in the animated dot sequence for HUD messages\. Must be greater than 0\.<br>These dots help indicate progress is happening to the user with a bit of animation which can be configured to animate at whatever speed is desired\.|
|rtx.gui.legacyTextureGuiShowAssignedOnly|bool|False|A setting to show only the textures in a category that are assigned to it \(Unassigned textures are found in the new "Uncategorized" list at the top\)\.<br>Requires: 'Split Texture Category List' option to be enabled\.|
|rtx.gui.reflexStatRangeInterpolationRate|float|0.05|A value controlling the interpolation rate applied to the Reflex stat graph ranges for smoother visualization\.|
|rtx.gui.reflexStatRangePaddingRatio|float|0.05|A value specifying the amount of padding applied to the Reflex stat graph ranges as a ratio to the calculated range\.|
|rtx.gui.showLegacyTextureGui|bool|False|A setting to toggle the old texture selection GUI, where each texture category is represented as its own list\.|
|rtx.gui.textureGridThumbnailScale|float|1|A float to set the scale of thumbnails while selecting textures\.<br>This will be scaled by the default value of 120 pixels\.<br>This value must always be greater than zero\.|
|rtx.hashCollisionDetection.enable|bool|False|Enables hash collision detection\.|
|rtx.hideSplashMessage|bool|False|A flag to disable the splash message indicating how to use Remix from appearing when the application starts\.<br>When set to true this message will be hidden, otherwise it will be displayed on every launch\.|
|rtx.ignoreGameDirectionalLights|bool|False|Ignores any directional lights coming from the original game \(lights added via toolkit still work\)\.|
|rtx.ignoreGamePointLights|bool|False|Ignores any point lights coming from the original game \(lights added via toolkit still work\)\.|
|rtx.ignoreGameSpotLights|bool|False|Ignores any spot lights coming from the original game \(lights added via toolkit still work\)\.|
|rtx.ignoreLastTextureStage|bool|False|Removes the last texture bound to a draw call, when using fixed\-function pipeline\. Primary textures are untouched\.<br>Might be set to true, if a game applies a lightmap as last shading step, to omit the original lightmap data\.|
|rtx.indirectRaySpreadAngleFactor|float|0.05|A tuning factor applied to the spread angle calculated from the sampled lobe solid angle PDF\. Should be 0\-1\.<br>This scaled spread angle is used to widen a ray's cone angle after indirect lighting BRDF samples to essentially prefilter the effects of the BRDF lobe's spread which potentially may reduce noise from indirect rays \(e\.g\. reflections\)\.<br>Prefiltering will overblur detail however compared to the ground truth of casting multiple samples especially given this calculated spread angle is a basic approximation and ray cones to begin with are a simple approximation for ray pixel footprint\.<br>As such rather than using the spread angle fully this spread angle factor allows it to be scaled down to something more narrow so that overblurring can be minimized\. Similarly, setting this factor to 0 disables this cone angle widening feature\.|
|rtx.initializer.asyncAssetLoading|bool|True|If true, a separate thread is created to load USD assets asynchronously\.|
|rtx.initializer.asyncShaderFinalizing|bool|True|When set to true, shader prewarming will be finalized asynchronously rather than Remix's initializer blocking synchronously until it is finished\.<br>Do note that this only controls if Remix waits for prewarming to finish or not on startup, if shaders are not finished prewarming by the time they are first used by Remix \(e\.g\. once ray tracing starts\) they will still block synchronously until finished even with this option set\. See rtx\.shader\.enableAsyncCompilation for true async shader compilation\.<br>This option should usually be set to true and is usually combined with async shader compilation to faciliate a better user experience, but can be to set to false to ensure all shaders are loaded to allow for slightly more deterministic behavior when debugging, or if prewarming all shaders before rendering is desired behavior \(at the cost of blocking on startup for a while\)\.<br>Finally, this option only takes effect for the most part when shader prewarming is enabled \(rtx\.initializer\.asyncShaderPrewarming\) as otherwise there will be no prewarmed shaders to worry about finalizing\.|
|rtx.initializer.asyncShaderPrewarming|bool|True|When set to true, shader prewarming will be enabled, allowing for Remix to start compiling shaders before their first use\.<br>Typically shaders will only begin compilation on their first use, but this is generally undesirable from a user experience perspective as this often causes stalls or wait times while using the application until all shaders have been used at least once\.<br>By prewarming permutations of potentially required shaders in advance this can be avoided by ensuring all required shaders are compiled before they are used\.<br>Additionally, this prewarming work can often be overlapped with an application's existing startup sequence \(e\.g\. the initial loading screen of a game\), allowing Remix's shaders to be ready before they are actually used and avoiding any stalls or wait times\.<br>As such this should generally be set to true and is often used in conjunction with rtx\.initializer\.asyncShaderFinalizing to avoid Remix blocking on initialization for the prewarming to complete, and rtx\.shader\.enableAsyncCompilation to avoid shaders from blocking if the application starts using Remix shaders before prewarming is complete\.<br>Since prewarming uses shader permutation however a greater amount of shaders will need to be compiled when this option is enabled compared to the minimal required set \(mainly to accomodate various runtime situations and user\-facing options that may be altered\)\. Setting this option to false may be useful in specific cases where minimizing this compilation cost is important over user experience \(e\.g\. for automated testing\)\.|
|rtx.instanceOverrideInstanceIdx|int|-1||
|rtx.instanceOverrideInstanceIdxRange|int|15||
|rtx.instanceOverrideSelectedInstancePrintMaterialHash|bool|False||
|rtx.instanceOverrideWorldOffset|float3|0, 0, 0||
|rtx.integrateIndirectMode|int|2|Indirect integration mode:<br>0: Importance Sampled\. Importance sampled mode uses typical GI sampling and it is not recommended for general use as it provides the noisiest output\.<br>   It serves as a reference integration mode for validation of other indirect integration modes\.<br>1: ReSTIR GI\. ReSTIR GI provides improved indirect path sampling over "Importance Sampled" mode <br>   with better indirect diffuse and specular GI quality at increased performance cost\.<br>2: Neural Radiance Cache \(NRC\)\. NRC is an AI based world space radiance cache\. It is live trained by the path tracer<br>   and allows paths to terminate early by looking up the cached value and saving performance\.<br>   NRC supports infinite bounces and often provides results closer to that of reference than ReSTIR GI<br>   while improving performance in scenarios where ray paths have 2 or more bounces on average\.<br>|
|rtx.io.enabled|bool|False|When this option is enabled the assets will be loaded \(and optionally decompressed on GPU\) using high performance RTX IO runtime\. RTX IO must be enabled for loading compressed assets, but is not necessary for working with loose uncompressed assets\.|
|rtx.io.forceCpuDecoding|bool|False|Force CPU decoding in RTX IO\.|
|rtx.io.memoryBudgetMB|int|256||
|rtx.io.useAsyncQueue|bool|True||
|rtx.isReflexEnabled|bool|True|Enables or disables Reflex globally\.<br>Note that this option when set to false will prevent Reflex from even attempting to initialize, unlike setting the Reflex mode to "None" which simply tells an initialized Reflex not to take effect\.<br>Additionally, this setting must be set at startup and changing it will not take effect at runtime\.|
|rtx.isShaderExecutionReorderingSupported|bool|True|Enables support of Shader Execution Reordering \(SER\) if it is supported by the target HW and SW\.|
|rtx.keepTexturesForTagging|bool|False|A flag to keep all textures in video memory, which can drastically increase VRAM consumption\. Intended to assist with tagging textures that are only used for a short period of time \(such as loading screens\)\. Use only when necessary\!|
|rtx.leftHandedCoordinateSystem|bool|False|Indicates that the world space coordinate system is left\-handed when true, otherwise right\-handed when false\.|
|rtx.legacyMaterial.albedoConstant|float3|1, 1, 1|The default albedo constant to use for non\-replaced "legacy" materials\. Should be a color in sRGB colorspace with gamma encoding\.|
|rtx.legacyMaterial.alphaIsThinFilmThickness|bool|False|A flag to determine if the alpha channel from the albedo source should be treated as thin film thickness on non\-replaced "legacy" materials\.|
|rtx.legacyMaterial.anisotropy|float|0|The default roughness anisotropy to use for non\-replaced "legacy" materials\. Should be in the range \-1 to 1, where 0 is isotropic\.|
|rtx.legacyMaterial.emissiveColorConstant|float3|0, 0, 0|The default emissive color constant to use for non\-replaced "legacy" materials\. Should be a color in sRGB colorspace with gamma encoding\.|
|rtx.legacyMaterial.emissiveIntensity|float|0|The default emissive intensity to use for non\-replaced "legacy" materials\.|
|rtx.legacyMaterial.enableEmissive|bool|False|A flag to determine if emission should be used on non\-replaced "legacy" materials\.|
|rtx.legacyMaterial.enableThinFilm|bool|False|A flag to determine if a thin\-film layer should be used on non\-replaced "legacy" materials\.|
|rtx.legacyMaterial.ignoreAlphaChannel|bool|False|A flag to determine if the albedo alpha channel should be ignored on non\-replaced "legacy" materials\.|
|rtx.legacyMaterial.metallicConstant|float|0.1|The default metallic constant to use for non\-replaced "legacy" materials\. Should be in the range 0 to 1\.|
|rtx.legacyMaterial.opacityConstant|float|1|The default opacity constant to use for non\-replaced "legacy" materials\. Should be in the range 0 to 1\.|
|rtx.legacyMaterial.roughnessConstant|float|0.7|The default perceptual roughness constant to use for non\-replaced "legacy" materials\. Should be in the range 0 to 1\.|
|rtx.legacyMaterial.thinFilmThicknessConstant|float|200|The thickness \(in nanometers\) of the thin\-film layer assuming it is enabled on non\-replaced "legacy" materials\.<br>Should be any value larger than 0, typically within the wavelength of light, but must be less than or equal to OPAQUE\_SURFACE\_MATERIAL\_THIN\_FILM\_MAX\_THICKNESS \(\(1500\.0f\) nm\)\.|
|rtx.legacyMaterial.useAlbedoTextureIfPresent|bool|True|A flag to determine if an "albedo" texture \(a qualifying color texture\) from the original application should be used if present on non\-replaced "legacy" materials\.|
|rtx.lightConversionDistantLightFixedAngle|float|0.0349|The angular size in radians of the distant light source for legacy lights converted to distant lights\. Set to ~2 degrees in radians by default\. Should only be within the range \[0, pi\]\.|
|rtx.lightConversionDistantLightFixedIntensity|float|1|The fixed intensity \(in W/sr\) to use for legacy lights converted to distant lights \(currently directional lights will convert to distant lights\)\.|
|rtx.lightConversionIntensityFactor|float|1|Scales the converted light intensities\.|
|rtx.lightConversionMaxIntensity|float|3.40282e+38|The highest intensity value a converted light can have\.|
|rtx.lightConversionSphereLightFixedRadius|float|4|The fixed radius in world units to use for legacy lights converted to sphere lights \(currently point and spot lights will convert to sphere lights\)\. Use caution with large light radii as many legacy lights will be placed close to geometry and intersect it, causing suboptimal light sampling performance or other visual artifacts \(lights clipping through walls, etc\)\.|
|rtx.lights.debugDrawLightHashes|bool|False|Draw light hashes of all visible ob screen lights, when enableDebugMode=true\.|
|rtx.lights.enableDebugMode|bool|False|Enables light debug visualization\.|
|rtx.limitedBonesPerVertex|int|4|Limit the number of bone influences per vertex for replacement geometry\.  D3D9 games were limited to 4, which is the default\.  In rare instances you may want to increase this based on your preference for replaced assets\.  This config only takes affect when set on startup via the rtx\.conf\.|
|rtx.localtonemap.boostLocalContrast|bool|False|Boosts contrast on local features\.|
|rtx.localtonemap.displayMip|int|0|Bottom mip level of tone map pyramid\.|
|rtx.localtonemap.ditherMode|int|2|Local tonemap dither mode selection, local tonemapping dithering has the same functionality and values as the global tonemapping dithering option, see rtx\.tonemap\.ditherMode for a more in\-depth description\.<br>Supported enum values are 0 = None \(Disabled\), 1 = Spatial \(Enabled, Spatial dithering only\), 2 = SpatialTemporal \(Enabled, Spatial and temporal dithering\)\.<br>|
|rtx.localtonemap.exposure|float|0.75|Exposure factor applied on average exposure\.|
|rtx.localtonemap.exposurePreferenceOffset|float|0|Offset to reference luminance when calculating the weights a pixel belongs to shadow/normal/highlight areas\.|
|rtx.localtonemap.exposurePreferenceSigma|float|4|Transition sharpness between different areas of exposure\. Smaller values result in sharper transitions\.|
|rtx.localtonemap.finalizeWithACES|bool|True|Applies ACES tone mapping on final result\.|
|rtx.localtonemap.highlights|float|4|Highlight area strength\. Higher values cause darker highlight\.|
|rtx.localtonemap.mip|int|3|Top mip level of tone map pyramid\.|
|rtx.localtonemap.shadows|float|2|Shadow area strength\. Higher values cause brighter shadows\.|
|rtx.localtonemap.useGaussian|bool|True|Uses gaussian kernel to generate tone map pyramid\.|
|rtx.logLegacyHashReplacementMatches|bool|False||
|rtx.lowMemoryGpu|bool|False|Enables low memory mode, where we aggressively detune caches and streaming systems to accomodate the lower memory available\.|
|rtx.maxAnisotropySamples|float|8|The maximum number of samples to use when anisotropic filtering is enabled\.<br>The actual max anisotropy used will be the minimum between this value and the hardware's maximum\. Higher values increase quality but will likely reduce performance\.|
|rtx.maxFogDistance|float|65504||
|rtx.maxPrimsInMergedBLAS|int|50000|The maximum number of triangles for a mesh that can be in the merged BLAS\.  |
|rtx.minOpaqueDiffuseLobeSamplingProbability|float|0.25|The minimum allowed non\-zero value for opaque diffuse probability weights\.|
|rtx.minOpaqueDiffuseTransmissionLobeSamplingProbability|float|0.25|The minimum allowed non\-zero value for thin opaque diffuse transmission probability weights\.|
|rtx.minOpaqueOpacityTransmissionLobeSamplingProbability|float|0.25|The minimum allowed non\-zero value for opaque opacity probability weights\.|
|rtx.minOpaqueSpecularLobeSamplingProbability|float|0.25|The minimum allowed non\-zero value for opaque specular probability weights\.|
|rtx.minPrimsInDynamicBLAS|int|1000|The minimum number of triangles required to promote a mesh to it's own BLAS, otherwise it lands in the merged BLAS with multiple other meshes\.|
|rtx.minTranslucentSpecularLobeSamplingProbability|float|0.3|The minimum allowed non\-zero value for translucent specular probability weights\.|
|rtx.minTranslucentTransmissionLobeSamplingProbability|float|0.25|The minimum allowed non\-zero value for translucent transmission probability weights\.|
|rtx.minimizeBlasMerging|bool|False|Minimize BLAS merging to the minimum possible, this option tries to give all meshes their own BLAS\.  This is generally not desirable forperformance, but can be a useful debugging tool\.|
|rtx.nativeMipBias|float|0|Specifies a mipmapping level bias to add to all material texture filtering\. Stacks with the upscaling mip bias\.<br>Mipmaps are determined based on how far away a texture is, using this can bias the desired level in a lower quality direction \(positive bias\), or a higher quality direction with potentially more aliasing \(negative bias\)\.<br>Note that mipmaps are also important for good spatial caching of textures, so too far negative of a mip bias may start to significantly affect performance, therefore changing this value is not recommended|
|rtx.nearPlaneOverride|float|0.1|The near plane value to use for the Camera when the near plane override is enabled\.<br>Only takes effect when rtx\.enableNearPlaneOverride is enabled, see that option for more information about why this is useful\.|
|rtx.neeCache.ageCullingSpeed|float|0.02|This threshold determines culling speed of an old triangle\. A triangle that is not detected for several frames will be deemed less important and culled quicker\.|
|rtx.neeCache.approximateParticleLighting|bool|True|Use particle albedo as emissive color\.|
|rtx.neeCache.cullingThreshold|float|0.01|Culling threshold\.|
|rtx.neeCache.emissiveTextureSampleFootprintScale|float|1|Emissive texture sample footprint scale\.|
|rtx.neeCache.enable|bool|True|Enable NEE cache\. The integrator will perform NEE on emissive triangles, which usually have significant light contributions, stored in the cache\.|
|rtx.neeCache.enableAnalyticalLight|bool|True|Enable NEE Cache on analytical light\.|
|rtx.neeCache.enableImportanceSampling|bool|True|Enable importance sampling\.|
|rtx.neeCache.enableMIS|bool|True|Enable MIS\.|
|rtx.neeCache.enableModeAfterFirstBounce|int|1|NEE Cache enable mode on a second and higher bounces\. 0 means off, 1 means enabled for specular rays only, 2 means always enabled\.|
|rtx.neeCache.enableOnFirstBounce|bool|True|Enable NEE Cache on a first bounce\.|
|rtx.neeCache.enableSpatialReuse|bool|True|Enable NEE cell share statistics information with neighbors\.|
|rtx.neeCache.enableTriangleExploration|bool|True|Explore emissive triangle candidates in the same object\.|
|rtx.neeCache.enableUpdate|bool|True|Enable Update\.|
|rtx.neeCache.learningRate|float|0.02|Learning rate\. Higher values makes the cache adapt to lighting changes more quickly\.|
|rtx.neeCache.minRange|float|400|The range for lowest level cells\.|
|rtx.neeCache.resolution|float|8|Cell resolution\. Higher values mean smaller cells\.|
|rtx.neeCache.specularFactor|float|1|Specular component factor\.|
|rtx.neeCache.triangleExplorationAcceptRangeRatio|float|0.33|Accept index range to search range ratio, when triangle exploration is enabled\.|
|rtx.neeCache.triangleExplorationMaxRange|int|20|Index range to explore, when triangle exploration is enabled\.|
|rtx.neeCache.triangleExplorationProbability|float|0.05|The probability to explore new triangles\.|
|rtx.neeCache.triangleExplorationRangeRatio|float|0.1|Index range to triangle count ratio, when triangle exploration is enabled\.|
|rtx.neeCache.uniformSamplingProbability|float|0.1|Uniform sampling probability\.|
|rtx.neuralRadianceCache.allowRussianRouletteOnUpdate|bool|False||
|rtx.neuralRadianceCache.averageTrainingBouncesPerPath|float|2.15|Average number of bounces per path used to calculate max training dimensions\.<br>Lower values result in higher max training dimensions and higher memory requirements by NRC\.<br>Lower values boost training dimensions to allows for more training records to get generated in scenes with very few / 1\-2 bounces<br>\(i\.e\. most of the view being into the sky with small geometric footprint on\-screen\)\.<br>|
|rtx.neuralRadianceCache.clearBuffersOnFrameStart|bool|False|Clears buffers for NRC before they are written to by the the Pathtracer\.|
|rtx.neuralRadianceCache.debugResolveMode|int|0|Debug Visualization Mode\.|
|rtx.neuralRadianceCache.enableAdaptiveTrainingDimensions|bool|True|Enables adaptive training dimensions that scale based off pathtracer's execution behavior on a given scene\.|
|rtx.neuralRadianceCache.enableCalculateTrainingLoss|bool|False|Enables calculation of a training loss\. Imposes a performance penalty\.|
|rtx.neuralRadianceCache.enableCustomNetworkConfig|bool|False|Enables usage of a custom config "CustomNetworkConfig\.json" for NRC\.<br>The file needs to be present in the application's working directory\.|
|rtx.neuralRadianceCache.enableDebugBuffers|bool|False|Enables Debug Buffers which are needed for a subset of debug visualization modes\.|
|rtx.neuralRadianceCache.enableDebugResolveMode|bool|False||
|rtx.neuralRadianceCache.enableNrcResolver|bool|False|Enables NRC radiance resolve by NRC's resolver\. Disable to use Remix's resolver\.|
|rtx.neuralRadianceCache.includeDirectLighting|bool|True||
|rtx.neuralRadianceCache.jitterSequenceLength|int|128|Halton sequence length to use for jittering training path to pixel mapping every frame\.<br>The sequence length governs how often the jitter distribution repeats\. Setting this to 0 disables jittering\.Training paths are mapped to a subset of pixels every frame, generally there is 1 training path per 100 pixels\.<br>The value to use should be same or slightly higher than the number of pixels per training path so that all pixels get cycled through over a smaller time window\.|
|rtx.neuralRadianceCache.learnIrradiance|bool|True||
|rtx.neuralRadianceCache.luminanceClampMultiplier|float|0|Luminance based clamp multiplier to use for clamping radiance passed to NRC during training\.<br>0: disables clamping\.<br>The clamp value is calculated as "luminanceClampMultiplier" \* "maxExpectedAverageRadianceValue"\.|
|rtx.neuralRadianceCache.maxExpectedAverageRadianceValue|float|2.5|NRC works better when the radiance values it sees internally are in a 'friendly' range for it\.<br>Applications often have quite different scales for their radiance units,<br>so we need to be able to scale these units in order to get that nice NRC \- friendly range\.<br>Set the value to an average radiance that you see in your bright scene \(e\.g\.outdoors in daylight\)\.|
|rtx.neuralRadianceCache.maxNumTrainingIterations|int|16|This controls the max number of training iterations to perform in a frame\.<br>When the pathtracer generates more training records than the ideal number of training records<br>based on "targetNumTrainingIterations", this parameter allows NRC SDK to use those records<br>to speed up the training at an increased cost instead of throwing the records away\.<br>Generally the pathtracer will try to reach the ideal number training records,<br>but in cases when its calibrating the workload during "numFramesToSmoothOutTrainingDimensions" frames it can overshoot it\.<br>This can happen when the cache resets on a level load or camera cut\. In such cases it is preferrable to speed the training up<br>to make the indirect lighting inference more accurate faster\.|
|rtx.neuralRadianceCache.numFramesToSmoothOutTrainingDimensions|int|16||
|rtx.neuralRadianceCache.proportionPrimarySegmentsToTrainOn|float|0.02||
|rtx.neuralRadianceCache.proportionTertiaryPlusSegmentsToTrainOn|float|1||
|rtx.neuralRadianceCache.proportionUnbiased|float|0.06||
|rtx.neuralRadianceCache.proportionUnbiasedToSelfTrain|float|1||
|rtx.neuralRadianceCache.qualityPreset|int|2|Quality Preset: Medium \(0\), High \(1\), Ultra \(2\)\.<br>Adjusts quality of Neural Radiance Cache \(NRC\):<br>  \- How quickly path\-tracer terminates paths into NRC cache\. It terminates quicker on lower presets\.<br>  \- Granularity of the cache \- i\.e\. the smallest resolvable feature size\. The cache is less precise on lower presets\.<br>  \- Responsiveness of the cache\. The cache is more responsive to dynamic lighting changes on higher presets\.<br>Lower quality presets result in faster path\-tracing with fewer bounces that may result in lower quality indirect lighting\.<br>Higher quality presets result in more responsive and detailed indirect lighting\.|
|rtx.neuralRadianceCache.resetHistory|bool|False||
|rtx.neuralRadianceCache.resetSceneBoundsOnCameraCut|bool|True|Resets scene bounds used by NRC Cache when a camera cut occurs\.<br>This is strongly recommended to leave enabled as otherwise the scene bounds would have to cover all geometry<br>across all camera cuts \(i\.e\. when loading into a new level\), which can be prohibitively expensive requiring<br>very large scene bounding box to cover geometry that can be loaded in from any level\.<br>|
|rtx.neuralRadianceCache.resolveAddNrcQueriedRadiance|bool|True||
|rtx.neuralRadianceCache.resolveAddPathTracedRadiance|bool|True||
|rtx.neuralRadianceCache.sceneBoundsWidthMeters|float|200|Minimum width of a 3D axis\-aligned bounding box in meters that will cover any in\-game scene\.<br>The width must be large enough to cover any scene and its geometry to ensure NRC cache coverage\.<br>The width must be large enough to contain any geometry that can be loaded during gameplay at any point\.<br>Note, "rtx\.neuralRadianceCache\.resetSceneBoundsOnCameraCut" controls whether the bounding box coverage resets on camera cuts\.<br>Note, larger values will result in increased memory and performance costs of NRC cache\.|
|rtx.neuralRadianceCache.selfTrainingAttenuation|float|1||
|rtx.neuralRadianceCache.skipDeltaVertices|bool|True||
|rtx.neuralRadianceCache.smallestResolvableFeatureSizeMeters|float|0.01||
|rtx.neuralRadianceCache.targetNumTrainingIterations|int|4|This controls the target number of training iterations to perform each frame,<br>which in turn determines the ideal number of training records that<br>the training/update path tracing pass is expected to generate\.<br>Each training batch contains 16K training records derived from path segments<br>in the the NRC update path tracing pass\. For example, 4 training iterations results in 64K training records\.<br>Higher number results in more responsive NRC cache at the cost of increased workload\.<br>|
|rtx.neuralRadianceCache.terminationHeuristicThreshold|float|0.1||
|rtx.neuralRadianceCache.trainCache|bool|True||
|rtx.neuralRadianceCache.trainingMaxPathBounces|int|15|The maximum number of indirect bounces the path will be allowed to complete during NRC Update path tracing pass\. Must be \< 16\.<br>NRC requires this value to be fairly high \(8\+\) for best lighting signal reconstruction\.<br>This value can be lower in games with darker surfaces and higher in games with albedos close to 1<br>and/or to reconstruct lighting phenomena requiring many bounces\.<br>Setting this parameter to a higher has no to minor performance and moderate memory requirements \(~10MiB per bounce\) impact\.|
|rtx.neuralRadianceCache.trainingMaxPathBouncesBiasInQualityPresets|int|0|This is a value added to the default "trainingMaxPathBounces" set by NRC quality presets\.<br>Set to negative value to lower the max number of training bounces and to a higher value to increase it in each quality preset\.|
|rtx.neuralRadianceCache.trainingTerminationHeuristicThreshold|float|0.25||
|rtx.nisPreset|int|1|Adjusts NIS scaling factor, trades quality for performance\.|
|rtx.numFramesToKeepBLAS|int|1||
|rtx.numFramesToKeepInstances|int|1||
|rtx.numFramesToKeepLights|int|100||
|rtx.numGeometryProcessingThreads|int|2|The desired number of CPU threads to dedicate to geometry processing  Will be limited by the number of CPU cores\.  There may be some advantage to lowering this number in games which are fairly simple and use a low number of draw calls per frame\.  The default was determined by looking at a game with around 2000 draw calls per frame, and with a reasonably high average triangle count per draw\.|
|rtx.opacityMicromap.buildRequests.customFiltersForBillboards|bool|True|Applies custom filters for staged Billboard requests\.|
|rtx.opacityMicromap.buildRequests.enableAnimatedInstances|bool|False|Enables Opacity Micromaps for animated instances\.|
|rtx.opacityMicromap.buildRequests.enableParticles|bool|True|Enables Opacity Micromaps for particles\.|
|rtx.opacityMicromap.buildRequests.filtering|bool|True|Enables filtering of Opacity Micromap requests\. Filtering reduces and slows down acceptance of Opacity Micromap requests to maximize resources to requests that are more likely to be reused across instances and frames\.|
|rtx.opacityMicromap.buildRequests.maxRequestFrameAge|int|300|Max request frame age to allow building Opacity Micromaps for\. Any requests older than this are purged\.|
|rtx.opacityMicromap.buildRequests.maxRequests|int|5000|Max number of staged unique Opacity Micromap build requests\.<br>Any further requests will simply be discarded until the number of staged requests decreases below this threshold\.<br>Once a staged request passes filters for building, it is removed from the staging list\.|
|rtx.opacityMicromap.buildRequests.minInstanceFrameAge|int|1|Min instance's frame age which to allow building Opacity Micromaps for\.|
|rtx.opacityMicromap.buildRequests.minNumFramesRequested|int|5|Min number of frames for a staged Opacity Micromap request before it is allowed to be built\.|
|rtx.opacityMicromap.buildRequests.minNumRequests|int|10|Min number of Opacity Micromap usage requests for a staged Opacity Micromap request before it is allowed to be built\.|
|rtx.opacityMicromap.building.allow2StateOpacityMicromaps|bool|True|Allows generation of two state Opacity Micromaps\.|
|rtx.opacityMicromap.building.conservativeEstimation.enable|bool|True|Enables Conservative Estimation of micro triangle opacities\.|
|rtx.opacityMicromap.building.conservativeEstimation.maxTexelTapsPerMicroTriangle|int|64|Max number of texel taps per micro triangle when Conservative Estimation is enabled\.<br>Set to 64 as a safer cap\. 512 has been found to cause a timeout\.<br>Any micro triangles requiring more texel taps will be tagged as Opaque Unknown\.|
|rtx.opacityMicromap.building.conservativeEstimation.maxTrianglesToCalculateTexelDensityForPerFrame|int|1536|Max number of triangles for which to calculate texel density in a frame\.<br>The higher the value, the lower latency in getting OMM data generated,<br>but at the cost of increasing CPU load per frame on the draw call submission thread\.|
|rtx.opacityMicromap.building.conservativeEstimation.minValidOMMTrianglesInMeshPercentage|float|0.75|Min percentage of triangles in a mesh for which valid OMM triangle arrays can be calculated\.<br>Valid OMM triangle arrays can be calculated for triangles for which the number of required texture taps is smaller or equal to "maxTexelTapsPerMicroTriangle"\.<br>If the criteria is not met for a mesh, the OMMs will not be generated for the mesh\.|
|rtx.opacityMicromap.building.costPerTexelTapPerMicroTriangleBudget|float|0.45|Approximate relative cost of doing an additional texel tap when baking micro triangles\.<br>This is used for estimating the overhead of baking micro triangles\.This cost is a relative cost to doing only a single tap\.<br>With C being the cost and N number of taps, the total cost is T = 1 \+ \(N \- 1\) \* C\.<br>|
|rtx.opacityMicromap.building.decalsMinResolveTransparencyThreshold|float|0|Min resolve transparency threshold for decals\.|
|rtx.opacityMicromap.building.enableUnlimitedBakingAndBuildingBudgets|bool|False|Enables unlimited baking and building budgets so that all available Opacity Micromaps are generated in a frame\.|
|rtx.opacityMicromap.building.enableVertexAndTextureOperations|bool|True|Applies vertex and texture operations during baking\.|
|rtx.opacityMicromap.building.force2StateOpacityMicromaps|bool|False|Forces generation of two state Opacity Micromaps\.|
|rtx.opacityMicromap.building.highWorkloadMultiplier|int|20|High workload multiplier that is applied to number of Opacity Micromaps to bake and build per frame\.<br>This is used for testing to decrease frame latency for Opacity Micromaps being ready\.|
|rtx.opacityMicromap.building.maxAllowedBillboardsPerInstanceToSplit|int|16|Max billboards per instance to consider for splitting \(large value results in increased CPU costs on BLAS builds\)\.|
|rtx.opacityMicromap.building.maxMicroTrianglesToBakeMillionPerSecond|int|300|Max Micro Triangles to bake \[Million/Second\]\.<br>The actual number of issued micro triangles also depends on "costPerTexelTapPerMicroTriangleBudget" option\.|
|rtx.opacityMicromap.building.maxMicroTrianglesToBuildMillionPerSecond|int|300|Max Micro Triangles to build \[Million/Second\]\.|
|rtx.opacityMicromap.building.numFramesAtStartToBuildWithHighWorkload|int|0|Number of frames at start to to bake and build Opacity Micromaps with high workload multiplier\.<br>This is used for testing to decrease frame latency for Opacity Micromaps being ready\.|
|rtx.opacityMicromap.building.splitBillboardGeometry|bool|True|Splits billboard geometry and corresponding Opacity Micromaps to quads for higher reuse\.<br>Games often batch instanced geometry that reuses same geometry and textures, such as for particles\.<br>Splitting such batches into unique subgeometries then allows higher reuse of build Opacity Micromaps\.|
|rtx.opacityMicromap.building.subdivisionLevel|int|8|Opacity Micromap subdivision level per triangle\. |
|rtx.opacityMicromap.cache.freeVidmemMBBudgetBuffer|int|384|A buffer of free memory on top of "minFreeVidmemMBToNotAllocate" to not budget OMMs for when calculating a new memory budget for OMMs\.<br>Note, "minFreeVidmemMBToNotAllocate" \+ "freeVidmemMBBudgetBuffer" is left untouched when calculating a new memory budget\.<br>However, once budget has been assigned to OMMs, the budget will not decrease until the free VidMem drops below "minFreeVidmemMBToNotAllocate"\.<br>Having this soft budget buffer protects OMM budget against runtime memory usage swings at high memory pressure<br>and keep it stable rather than the budget being continously bumped and decreased in oscilating manner,<br>which is detrimental since OMM build workloads are spread across multiple frames\.|
|rtx.opacityMicromap.cache.hashInstanceIndexOnly|bool|False|Uses instance index as an Opacity Micromap hash\.|
|rtx.opacityMicromap.cache.maxBudgetSizeMB|int|1536|Budget: Max Allowed Size \[MB\]\.|
|rtx.opacityMicromap.cache.maxVidmemSizePercentage|float|0.15|Budget: Max Video Memory Size %\.|
|rtx.opacityMicromap.cache.minBudgetSizeMB|int|128|Budget: Min Video Memory \[MB\] required\.<br>If the min amount is not available, then the budget will be set to 0\.|
|rtx.opacityMicromap.cache.minFreeVidmemMBToNotAllocate|int|512|Min Video Memory \[MB\] to keep free before allocating any for Opacity Micromaps\.|
|rtx.opacityMicromap.cache.minUsageFrameAgeBeforeEviction|int|900|Min Opacity Micromap usage frame age before eviction\.<br>Opacity Micromaps unused longer than this can be evicted when freeing up memory for new Opacity Micromaps\.|
|rtx.opacityMicromap.enable|bool|True|Enables Opacity Micromaps for geometries with textures that have alpha cutouts\.<br>This is generally the case for geometries such as fences, foliage, particles, etc\. \.<br>Opacity Micromaps greatly speed up raytracing of partially opaque triangles\.<br>Examples of scenes that benefit a lot: multiple trees with a lot of foliage,<br>a ground densely covered with grass blades or steam consisting of many particles\.|
|rtx.opacityMicromap.enableBakingArrays|bool|True|Enables baking of opacity textures into Opacity Micromap arrays per triangle\.|
|rtx.opacityMicromap.enableBinding|bool|True|Enables binding of built Opacity Micromaps to bottom level acceleration structures\.|
|rtx.opacityMicromap.enableBuilding|bool|True|Enables building of Opacity Micromap arrays\.|
|rtx.opacityMicromap.enableResetEveryFrame|bool|False|Debug: resets Opacity Micromap runtime data every frame\. |
|rtx.opacityMicromap.showAdvancedOptions|bool|False|Shows advanced options\.|
|rtx.opaqueDiffuseLobeSamplingProbabilityZeroThreshold|float|0.01|The threshold for which to zero opaque diffuse probability weight values\.|
|rtx.opaqueDiffuseTransmissionLobeSamplingProbabilityZeroThreshold|float|0.01|The threshold for which to zero thin opaque diffuse transmission probability weight values\.|
|rtx.opaqueMaterial.albedoBias|float|0|A bias factor to add to all albedo values in the opaque material\. Should only be used for debugging or development\.|
|rtx.opaqueMaterial.albedoScale|float|1|A scale factor to apply to all albedo values in the opaque material\. Should only be used for debugging or development\.|
|rtx.opaqueMaterial.enableThinFilmOverride|bool|False|A flag to force the thin\-film layer on the opaque material to be enabled\. Should only be used for debugging or development\.|
|rtx.opaqueMaterial.ignoreAlphaChannelOverride|bool|False|A flag to ignore the alpha channel of the colormap on the opaque material\. Should only be used for debugging or development\.|
|rtx.opaqueMaterial.layeredWaterNormalEnable|bool|True|A flag indicating if layered water normal should be enabled or disabled\.<br>Note that objects must be properly classified as animated water to be rendered with this mode\.|
|rtx.opaqueMaterial.layeredWaterNormalLodBias|float|5|The LoD bias to use when sampling from the normal map on layered water for the second layer of detail\.<br>This value typically should be greater than 0 to allow for a more blurry mip to be selected as this allows for a low frequency variation of normals to be applied to the higher frequency variation from the typical normal map\.<br>Only takes effect when layered water normals are enabled \(and an object is properly classified as animated water\)\.|
|rtx.opaqueMaterial.layeredWaterNormalMotion|float2|-0.25, -0.3|A vector describing the motion in the U and V axes across a texture to apply for layered water\.<br>Only takes effect when layered water normals are enabled \(and an object is properly classified as animated water\)\.|
|rtx.opaqueMaterial.layeredWaterNormalMotionScale|float|9|A scale factor applied to the layered water normal motion vector\.<br>Only takes effect when layered water normals are enabled \(and an object is properly classified as animated water\)\.|
|rtx.opaqueMaterial.metallicBias|float|0|A bias factor to add to all metallic values in the opaque material\. Should only be used for debugging or development\.|
|rtx.opaqueMaterial.metallicScale|float|1|A scale factor to apply to all metallic values in the opaque material\. Should only be used for debugging or development\.|
|rtx.opaqueMaterial.normalIntensity|float|1|An arbitrary strength scale factor to apply when decoding normals in the opaque material\. Should only be used for debugging or development\.|
|rtx.opaqueMaterial.roughnessBias|float|0|A bias factor to add to all roughness values in the opaque material\. Should only be used for debugging or development\.|
|rtx.opaqueMaterial.roughnessScale|float|1|A scale factor to apply to all roughness values in the opaque material\. Should only be used for debugging or development\.|
|rtx.opaqueMaterial.thinFilmThicknessOverride|float|0|The thin\-film layer's thickness in nanometers for the opaque material when the thin\-film override is enabled\.<br>Should be any value larger than 0, typically within the wavelength of light, but must be less than or equal to OPAQUE\_SURFACE\_MATERIAL\_THIN\_FILM\_MAX\_THICKNESS \(\(1500\.0f\) nm\)\.<br>Should only be used for debugging or development\.|
|rtx.opaqueOpacityTransmissionLobeSamplingProbabilityZeroThreshold|float|0.01|The threshold for which to zero opaque opacity probability weight values\.|
|rtx.opaqueSpecularLobeSamplingProbabilityZeroThreshold|float|0.01|The threshold for which to zero opaque specular probability weight values\.|
|rtx.orthographicIsUI|bool|True|When enabled, draw calls that are orthographic will be considered as UI\.|
|rtx.particleSoftnessFactor|float|0.05|Multiplier for the view distance that is used to calculate the particle blending range\.|
|rtx.pathMaxBounces|int|4|The maximum number of indirect bounces the path will be allowed to complete\. Must be \< 16\.<br>Higher values result in better indirect lighting quality due to biasing the signal less, lower values result in better performance\.<br>Very high values are not recommended however as while long paths may be technically needed for unbiased rendering, in practice the contributions from higher bounces have diminishing returns\.|
|rtx.pathMinBounces|int|1|The minimum number of indirect bounces the path must complete before Russian Roulette can be used\. Must be \< 16\.<br>This value is recommended to stay fairly low \(1 for example\) as forcing longer paths when they carry little contribution quickly becomes detrimental to performance\.|
|rtx.pipeline.useDeferredOperations|bool|True||
|rtx.pixelHighlightReuseStrength|float|0.5|The specular portion when we reuse last frame's pixel value\.|
|rtx.playerModel.backwardOffset|float|0||
|rtx.playerModel.enableInPrimarySpace|bool|False||
|rtx.playerModel.enablePrimaryShadows|bool|True||
|rtx.playerModel.enableVirtualInstances|bool|True||
|rtx.playerModel.eyeHeight|float|64||
|rtx.playerModel.horizontalDetectionDistance|float|34||
|rtx.playerModel.intersectionCapsuleHeight|float|68||
|rtx.playerModel.intersectionCapsuleRadius|float|24||
|rtx.playerModel.verticalDetectionDistance|float|64||
|rtx.postFilterThreshold|float|3|Clamps a pixel when its luminance exceeds x times of the average\.|
|rtx.postfx.blurDiameterFraction|float|0.02|The diameter of the circle that motion blur samplings occur\. Motion vectors beyond this circle will be clamped\.|
|rtx.postfx.chromaticAberrationAmount|float|0.02|The strength of chromatic aberration\.|
|rtx.postfx.chromaticCenterAttenuationAmount|float|0.975|Control the amount of chromatic aberration effect that attunuated when close to the center of screen\.|
|rtx.postfx.desaturateOthersOnHighlight|bool|True|If true, desaturare all objects that are not highlighted\.|
|rtx.postfx.enable|bool|True|Enables post\-processing effects\.|
|rtx.postfx.enableChromaticAberration|bool|True|Enables chromatic aberration post\-processing effect\.|
|rtx.postfx.enableMotionBlur|bool|True|Enables motion blur post\-processing effect\.|
|rtx.postfx.enableMotionBlurEmissive|bool|True|Enable Motion Blur for Emissive surfaces\. Disable this when the motion blur on emissive surfaces cause severe artifacts\.|
|rtx.postfx.enableMotionBlurNoiseSample|bool|True|Enable random distance sampling for every step along the motion vector\. The random pattern is generated with interleaved gradient noise\.|
|rtx.postfx.enableVignette|bool|True|Enables vignette post\-processing effect\.|
|rtx.postfx.exposureFraction|float|0.4|Simulate the camera exposure, the longer exposure will cause stronger motion blur\.|
|rtx.postfx.motionBlurDynamicDeduction|float|1|The deduction of motion blur for dynamic objects\.|
|rtx.postfx.motionBlurJitterStrength|float|0.6|The jitter strength of every sample along the motion vector\.|
|rtx.postfx.motionBlurMinimumVelocityThresholdInPixel|float|1|The minimum motion vector distance that enable the motion blur\. The unit is pixel size\.|
|rtx.postfx.motionBlurSampleCount|int|4|The number of samples along the motion vector\. More samples could help to reduce motion blur noise\.|
|rtx.postfx.vignetteIntensity|float|0.8|The darkness of vignette effect\.|
|rtx.postfx.vignetteRadius|float|0.8|The radius that vignette effect starts\. The unit is normalized screen space, 0 represents the center, 1 means the edge of the short edge of the rendering window\. So, this setting can larger than 1 until reach to the long edge of the rendering window\.|
|rtx.postfx.vignetteSoftness|float|0.2|The gradient that the color drop to black from the vignetteRadius to the edge of rendering window\.|
|rtx.presentThrottleDelay|int|16|A time in milliseconds that the DXVK presentation thread should sleep for\. Requires present throttling to be enabled to take effect\.<br>Note that the application may sleep for longer than the specified time as is expected with sleep functions in general\.|
|rtx.primaryRayMaxInteractions|int|32|The maximum number of resolver interactions to use for primary \(initial G\-Buffer\) rays\.<br>This affects how many Decals, Ray Portals and potentially particles \(if unordered approximations are not enabled\) may be interacted with along a ray at the cost of performance for higher amounts of interactions\.|
|rtx.profiler.memory.enable|bool|False|Enables the memory profiler which allows users to inspect Remix resources using the profiler tool in the Dev Settings Remix window\.  This option is disabled by default, and must be enabled from application launch to work correctly\.|
|rtx.profiler.memory.includeWholeFrame|bool|False|Profiles memory across the entire frame when enabled\.  When disabled we only see a snapshot of memory at the time of sampling\.  This has some additional CPU performance overhead so is disabled by default\.|
|rtx.psrRayMaxInteractions|int|32|The maximum number of resolver interactions to use for PSR \(primary surface replacement G\-Buffer\) rays\.<br>This affects how many Decals, Ray Portals and potentially particles \(if unordered approximations are not enabled\) may be interacted with along a ray at the cost of performance for higher amounts of interactions\.|
|rtx.psrrMaxBounces|int|10|The maximum number of Reflection PSR bounces to traverse\. Must be 15 or less due to payload encoding\.<br>Should be set higher when many mirror\-like reflection bounces may be needed, though more bounces may come at a higher performance cost\.|
|rtx.psrrNormalDetailThreshold|float|0|A threshold value to indicate that the denoiser's alternate disocclusion threshold should be used when normal map "detail" on a reflection PSR surface exceeds a desired amount\.<br>Normal detail is defined as 1\-dot\(tangent\_normal, vec3\(0, 0, 1\)\), or in other words it is 0 when no normal mapping is used, and 1 when the normal mapped normal is perpendicular to the underlying normal\.<br>This is typically used to reduce flickering artifacts resulting from reflection on surfaces like glass leveraging normal maps as often the denoiser is too aggressive with disocclusion checks frame to frame when DLSS or other camera jittering is in use\.|
|rtx.pstrMaxBounces|int|10|The maximum number of Transmission PSR bounces to traverse\. Must be 15 or less due to payload encoding\.<br>Should be set higher when refraction through many layers of glass may be needed, though more bounces may come at a higher performance cost\.|
|rtx.pstrNormalDetailThreshold|float|0|A threshold value to indicate that the denoiser's alternate disocclusion threshold should be used when normal map "detail" on a transmission PSR surface exceeds a desired amount\.<br>Normal detail is defined as 1\-dot\(tangent\_normal, vec3\(0, 0, 1\)\), or in other words it is 0 when no normal mapping is used, and 1 when the normal mapped normal is perpendicular to the underlying normal\.<br>This is typically used to reduce flickering artifacts resulting from refraction on surfaces like glass leveraging normal maps as often the denoiser is too aggressive with disocclusion checks frame to frame when DLSS or other camera jittering is in use\.|
|rtx.qualityDLSS|int|4|Adjusts internal DLSS scaling factor, trades quality for performance\.|
|rtx.rayPortalCameraHistoryCorrection|bool|False|A flag to control if history correction on ray portal camera teleportation events is enabled or disabled\.<br>This allows for the previous camera matrix to be set to a virtual matrix to correct the large discontunity in position and view direction which happens when a camera teleports from moving through a ray portal \(in games like Portal\)\.<br>As such this option should always be enabled in games utilizing ray portals the camera can pass through as it should fix artifacts from incorrectly calculated motion vectors or other deltas that rely on the current and previous camera matrix\.|
|rtx.rayPortalCameraInBetweenPortalsCorrection|bool|False|A flag to contol correction when the camera is "in\-between" a pair of ray portals\.<br>This is mostly relevant in applications which allow the camera to move through a ray portal \(games like Portal\) as often the ray portals are placed slightly off of a surface, allowing the camera to sometimes end up in this tiny gap for a frame\.<br>To correct this artifact \(as it can mess up denoising and other temporal surface consistency checks due to the sudden frame of geometry in front of the camera\) this option pushes the camera slightly backwards if this occurs when entering a ray portal\.<br>Similar to ray portal camera history correction this option should always be enabled in games utilizing ray portals the camera can pass through\.|
|rtx.rayPortalCameraInBetweenPortalsCorrectionThreshold|float|0.1|The threshold to use for camera "in\-between" ray portal detection in meters\.<br>When the camera is less than this distance behind the surface of a ray portal it will be pushed backwards to stay behind the ray portal\.<br>This value should stay small but be large enough to cover the gap between ray portals and the geometry behind them \(if such a gap exists in the underlying application\)\.<br>Additionally, this setting must be set at startup and changing it will not take effect at runtime\.|
|rtx.rayPortalEnabled|bool|False|Enables ray portal support\. Note this requires portal texture hashes to be set for the ray portal geometries in rtx\.rayPortalModelTextureHashes\.|
|rtx.rayPortalModelHeightAxis|float3|0, 1, 0|The axis in object space to map the ray portal geometry's height axis to\. Currently unused \(as PCA is not implemented\)\.|
|rtx.rayPortalModelNormalAxis|float3|0, 0, 1|The axis in object space to map the ray portal geometry's normal axis to\. Currently unused \(as PCA is not implemented\)\.|
|rtx.rayPortalModelWidthAxis|float3|1, 0, 0|The axis in object space to map the ray portal geometry's width axis to\. Currently unused \(as PCA is not implemented\)\.|
|rtx.rayPortalSamplingWeightMaxDistance|float|1000|The maximum distance from a portal which the interpolation of the probability of light sampling through portals will end \(and is at its minimum value such that no portal light sampling will happen beyond this point\)\.<br>Currently unimplemented, kept here for future use\.|
|rtx.rayPortalSamplingWeightMinDistance|float|10|The minimum distance from a portal which the interpolation of the probability of light sampling through portals will begin \(and is at its maximum value\)\.<br>Currently unimplemented, kept here for future use\.|
|rtx.rayreconstruction.combineSpecularAlbedo|bool|True|Combine primary and secondary specular albedo to improve DLSS\-RR reflection quality\.<br>|
|rtx.rayreconstruction.compositeVolumetricLight|bool|True|Composite volumetric light and then input the result to DLSS\-RR, otherwise volumetric light is in a separate layer\. Disabling it may introduce flickering artifacts\.<br>|
|rtx.rayreconstruction.demodulateAttenuation|bool|True|Demodulate attenuation to reduce ghosting when an object is behind textured translucent objects\.<br>|
|rtx.rayreconstruction.demodulateRoughness|bool|True|Demodulate roughness to enhance roughness details\.<br>|
|rtx.rayreconstruction.enableDLSSRRSurfaceReplacement|bool|True|Use DLSS\-RR surface replacement\. Translucent surfaces with significant refraction are excluded from surface replacement and its surface motion vector will be used\.<br>|
|rtx.rayreconstruction.enableDetailEnhancement|bool|True|Enable detail enhancement filter to enhance normal map details\.<br>|
|rtx.rayreconstruction.enableNRDForTraining|bool|False|Enable NRD\. This option is only for training or debug purpose\.<br>|
|rtx.rayreconstruction.enableTransformerModelD|bool|False||
|rtx.rayreconstruction.filterHitT|bool|True|Filter hit distance to improve specular reflection quality\.<br>|
|rtx.rayreconstruction.model|int|1|Ray reconstruction model to use\. 0: CNN, 1: Transformer \(higher quality\)\.|
|rtx.rayreconstruction.particleBufferMode|int|1|Use a separate particle buffer to handle particles\.<br>|
|rtx.rayreconstruction.pathTracerPreset|int|1|Path tracer preset to use when Ray Reconstruction is enabled\.|
|rtx.rayreconstruction.preprocessSecondarySignal|bool|True|Denoise secondary signal before passing to DLSS\-RR\. This option improves reflection on translucent objects\.<br>|
|rtx.rayreconstruction.preserveSettingsInNativeMode|bool|False|Preserve settings when switched to native mode, otherwise the default preset will be applied\.<br>|
|rtx.rayreconstruction.upscalerRoughnessDemodulationMultiplier|float|0.15|Multiplier of upscaler roughness demodulation to suppress noise\. Only used by DLSS\-RR\.|
|rtx.rayreconstruction.upscalerRoughnessDemodulationOffset|float|1.5|Strength of upscaler roughness demodulation\. Only used by DLSS\-RR\.|
|rtx.rayreconstruction.useSpecularHitDistance|bool|True|Use specular hit distance to reduce ghosting\.<br>|
|rtx.raytraceModePreset|int|1||
|rtx.raytracedRenderTarget.enable|bool|True|Enables or disables raytracing for render\-to\-texture effects\.  The render target to be raytraced must be specified in the texture selection menu\.|
|rtx.reflexMode|int|1|Reflex mode selection, enabling it helps minimize input latency, boost mode may further reduce latency by boosting GPU clocks in CPU\-bound cases\.<br>Supported enum values are 0 = None \(Disabled\), 1 = LowLatency \(Enabled\), 2 = LowLatencyBoost \(Enabled \+ Boost\)\.<br>Note that even when using the "None" Reflex mode Reflex will attempt to be initialized\. Use rtx\.isReflexEnabled to fully disable to skip this initialization if needed\.|
|rtx.reloadTextureWhenResolutionChanged|bool|False|Reload texture when resolution changed\.|
|rtx.renderPassGBufferRaytraceMode|int|0|The ray tracing mode to use for the G\-Buffer pass which resolves the initial primary and secondary surfaces to apply lighting to\.|
|rtx.renderPassIntegrateDirectRaytraceMode|int|0|The ray tracing mode to use for the Direct Lighting pass which applies lighting to the primary/secondary surfaces\.|
|rtx.renderPassIntegrateIndirectRaytraceMode|int|2|The ray tracing mode to use for the Indirect Lighting pass which applies lighting to the primary/secondary surfaces\.|
|rtx.replaceDirectSpecularHitTWithIndirectSpecularHitT|bool|True||
|rtx.resetDenoiserHistoryOnSettingsChange|bool|False||
|rtx.resolutionScale|float|0.75||
|rtx.resolveOpaquenessThreshold|float|0.996078|A threshold for which any opacity value above is considered totally opaque\.|
|rtx.resolvePreCombinedMatrices|bool|True||
|rtx.resolveTransparencyThreshold|float|0.00392157|A threshold for which any opacity value below is considered totally transparent and may be safely skipped without as significant of a performance cost\.|
|rtx.restirGI.DLSSRRTemporalRandomizationRadius|int|80|In DLSS\-RR compatibility mode temporal reprojection is randomized to reduce sample coherency\. This option determines the randomization radius\.|
|rtx.restirGI.biasCorrectionMode|int|4|Bias correction mode to combine central with its neighbors in spatial reuse\.|
|rtx.restirGI.boilingFilterMaxThreshold|float|20|Boiling filter threshold when surface normal is parallel to view direction\.|
|rtx.restirGI.boilingFilterMinThreshold|float|10|Boiling filter threshold when surface normal is perpendicular to view direction\.|
|rtx.restirGI.boilingFilterRemoveReservoirThreshold|float|62|Removes a sample when a sample's weight exceeds this threshold\.|
|rtx.restirGI.fireflyThreshold|float|50|Clamps specular input to suppress boiling\.|
|rtx.restirGI.historyDiscardStrength|float|0|The sensitivity of discarding history\. Higher values discard more history\.|
|rtx.restirGI.lightingValidationThreshold|float|0.5|Invalidate a sample when pixel change ratio is above this value\.|
|rtx.restirGI.misMode|int|2|MIS mode to mix specular output with input\.|
|rtx.restirGI.misRoughness|float|0.3|Reference roughness when roughness MIS is used\. Higher values give ReSTIR inputs higher weight\.|
|rtx.restirGI.pairwiseMISCentralWeight|float|0.1|The importance of central sample in pairwise bias correction modes\.|
|rtx.restirGI.parallaxAmount|float|0.02|Parallax strength when parallax MIS is used\. Higher values give ReSTIR inputs higher weight\.|
|rtx.restirGI.permutationSamplingSize|int|2|Permutation sampling strength\.|
|rtx.restirGI.reflectionMinParallax|float|3|When the parallax between normal and reflection reprojection is greater than this threshold, randomly choose one reprojected position and reuse the sample on it\. Otherwise, get a sample between the two positions\.|
|rtx.restirGI.roughnessClamp|float|0.01|Clamps minimum roughness a sample's importance is evaluated\.|
|rtx.restirGI.sampleStealingJitter|float|0|Jitter samples by k pixels to avoid aliasing\.|
|rtx.restirGI.stealBoundaryPixelSamplesWhenOutsideOfScreen|bool|True|Steals ReSTIR GI samples even a hit point is outside the screen\. This will further improve highly specular samples at the cost of some bias\.|
|rtx.restirGI.temporalAdaptiveHistoryLengthMs|int|500|Temporal history time length, when adaptive temporal history is enabled\.|
|rtx.restirGI.temporalFixedHistoryLength|int|30|Fixed temporal history length, when adaptive temporal history is disabled\.|
|rtx.restirGI.useAdaptiveTemporalHistory|bool|True|Adjust temporal history length based on frame rate\.|
|rtx.restirGI.useBoilingFilter|bool|True|Enables boiling filter to suppress boiling artifacts\.|
|rtx.restirGI.useDLSSRRCompatibilityMode|bool|False|DLSS\-RR compatibility mode\. In this mode temporal reprojection is randomized to reduce sample coherency\.|
|rtx.restirGI.useDemodulatedTargetFunction|bool|False|Demodulates target function\. This will improve the result in non\-pairwise modes\.|
|rtx.restirGI.useDiscardEnlargedPixels|bool|True|Discards enlarged samples when the camera is moving towards an object\.|
|rtx.restirGI.useFinalVisibility|bool|True|Tests visiblity in output\.|
|rtx.restirGI.usePermutationSampling|bool|True|Uses permutation sample to perturb samples\. This will improve results in DLSS\.|
|rtx.restirGI.useReflectionReprojection|bool|True|Uses reflection reprojection for reflective objects to achieve stable result when the camera is moving\.|
|rtx.restirGI.useSampleStealing|int|2|Steals ReSTIR GI samples in path tracer\. This will improve highly specular results\.|
|rtx.restirGI.useSpatialReuse|bool|True|Enables spatial reuse\.|
|rtx.restirGI.useTemporalBiasCorrection|bool|True|Corrects bias caused by temporal reprojection\.|
|rtx.restirGI.useTemporalJacobian|bool|True|Calculates Jacobian determinant in temporal reprojection\.|
|rtx.restirGI.useTemporalReuse|bool|True|Enables temporal reuse\.|
|rtx.restirGI.useVirtualSample|bool|True|Uses virtual position for samples from highly specular surfaces\.|
|rtx.restirGI.validateLightingChange|bool|True|Remove samples when direct light has changed\.|
|rtx.restirGI.validateVisibilityChange|bool|False|Remove samples when visibility has changed\. This feature is automatically disabled when virtual sample is enabled\.|
|rtx.restirGI.virtualSampleLuminanceThreshold|float|2|The last path vertex with luminance greater than 2 times of the previous accumulated radiance will get virtualized\. Higher values tend to keep the first path vertex with non\-zero contribution\.|
|rtx.restirGI.virtualSampleMaxDistanceRatio|float|0|Clamp max virtual distance, measured by the proportion of distance to camera\. 0 disables clamping\.|
|rtx.restirGI.virtualSampleRoughnessThreshold|float|0.2|Surface with roughness under this threshold is considered to be highly specular, i\.e\. a "mirror"\.|
|rtx.restirGI.virtualSampleSpecularThreshold|float|0.5|If a highly specular path vertex's direct specular light portion is higher than this\. Its distance to the light source will get accumulated\.|
|rtx.restirGI.visibilityValidationRange|float|0.05|Check actual hit distance of a shadow ray, invalidate a sample if hit length is longer than one plus this portion, compared to the distance from the surface to the sample\.|
|rtx.risLightSampleCount|int|7|The number of lights randomly selected from the global pool to consider when selecting a light with RIS\.<br>Higher values generally increases the quality of RIS light sampling, but also has diminishing returns and higher performance cost past a point\.<br>Note that RIS is only used when RTXDI is disabled for direct lighting, or for light sampling in indirect rays, so the impact of this effect will vary\.|
|rtx.rngSeedWithFrameIndex|bool|True|Indicates that pseudo\-random number generator should be seeded with the frame number of the application every frame, otherwise seed with 0\.<br>This should generally always be enabled as without the frame index each frame will typically be identical in the random values that are produced which will result in incorrect rendering\. Only meant as a debugging tool\.|
|rtx.russianRoulette1stBounceMaxContinueProbability|float|1|The maximum probability of continuing a path when Russian Roulette is being used on the first bounce\.<br>This is similar to the usual max continuation probability for Russian Roulette, but specifically only for the first bounce\.|
|rtx.russianRoulette1stBounceMinContinueProbability|float|0.6|The minimum probability of continuing a path when Russian Roulette is being used on the first bounce\.<br>This ensures that on the first bounce rays are not terminated too aggressively as it may be useful for some denoisers to have a contribution even if it is a relatively unimportant one rather than a missing indirect sample\.|
|rtx.russianRouletteDiffuseContinueProbability|float|0.1|The probability of continuing a diffuse path when Russian Roulette is being used\. Only apply to specular based mode\.<br>|
|rtx.russianRouletteDistanceFactor|float|0.1|Path segments whose distance proportion are under this threshold are more likely to continue\. Only apply to specular based mode\.<br>|
|rtx.russianRouletteMaxContinueProbability|float|0.9|The maximum probability of continuing a path when Russian Roulette is being used\.<br>This ensures all rays have a small probability of terminating each bounce, mostly to prevent infinite paths in perfectly reflective mirror rooms \(though the maximum path bounce count will also ensure this\)\.|
|rtx.russianRouletteMode|int|0|Russian Roulette Mode\. Throughput Based: paths with higher throughput become longer; Specular Based: specular paths become longer\.<br>|
|rtx.russianRouletteSpecularContinueProbability|float|0.98|The probability of continuing a specular path when Russian Roulette is being used\. Only apply to specular based mode\.<br>|
|rtx.sceneScale|float|1|Defines the ratio of rendering unit \(1cm\) to game unit, i\.e\. sceneScale = 1cm / GameUnit\.|
|rtx.secondaryRayMaxInteractions|int|8|The maximum number of resolver interactions to use for secondary \(indirect\) rays\.<br>This affects how many Decals, Ray Portals and potentially particles \(if unordered approximations are not enabled\) may be interacted with along a ray at the cost of performance for higher amounts of interactions\.<br>This value is recommended to be set lower than the primary/PSR max ray interactions as secondary ray interactions are less visually relevant relative to the performance cost of resolving them\.|
|rtx.secondarySpecularFireflyFilteringThreshold|float|1000|Firefly luminance clamping threshold for secondary specular signal\.|
|rtx.serializeChangedOptionOnly|bool|True||
|rtx.shader.asyncCompilationThrottleMilliseconds|int|33|Specifies a time in milliseconds to throttle each application frame when async shader compilation is in progress\. Set to 0 to disable, and only takes effect when rtx\.shader\.enableAsyncCompilation is true\.<br>This generally should be set to a value low enough to not impact the application framerate significantly \(especially if non\-ray traced visuals are capable of being displayed by the application while loading, e\.g\. an intro video\), but also high enough to get the desired shader compilation performance \(especially relevant if the application is fairly heavy on the CPU during async shader compilation, or on CPUs with few hardware threads\)\.|
|rtx.shader.asyncSpirVRecompilation|bool|True|When set to true runtime shader recompilation will recompile shaders to SPIR\-V asynchronously rather than blocking until complete\.<br>Do note that despite setting this option the actual compilation of the shader from SPIR\-V to the ISA will still be blocking as only the prewarming process can handle this step asynchronously for now\.<br>Generally this option should remain enabled, though disabling it may be useful for CI where deterministic behavior is needed, and may be useful to maximize performance at the cost of blocking \(by not having application running while compiling to SPIR\-V\)\.<br>This option is mainly meant for development use and should not be set for user\-facing operation\.|
|rtx.shader.enableAsyncCompilation|bool|True|When set to true shader compilation \(especially that of prewarming\) will be done asynchronously rather than blocking\.<br>Typically shader prewarming with async finalization is done to attempt to compile all required shader variants before they are used, often by overlapping this work with a startup sequence \(e\.g\. a game's loading screen\)\. Often times however this prewarming takes longer than the time available, or an application may not have a startup sequence to begin with and immediately begin using Remix shaders\.<br>To accomodate this, async shader compilation allows for this work to be done asynchronously to avoid blocking the application at the cost of being unable to render anything until the process is complete\.<br>This is typically better choice than blocking however and is recommended to be enabled as on Windows Remix blocking will cause the application to stop responding, making it seem as if the application has crashed if shader compilation takes a long time\. Additionally, when combined with rtx\.shader\.enableAsyncCompilationUI the progress of the compilation process can be shown to the user as a UI, improving user experience\.<br>The main downside to this approach is that when blocking shader compilation is allowed to take up more of the CPU, whereas async shader compilation will have to compete with the application which can make compilation take slightly longer than it would otherwise \(especially true if the application's framerate is uncapped\)\.<br>To mitigate this, Remix can optionally throttle the application during async compilation via rtx\.shader\.asyncCompilationThrottleMilliseconds to ensure enough time is available for compilation\.<br>Finally, a more minor downside is that when async shader compilation is in use Remix currently has no way of keeping the application in a startup sequence \(e\.g\. keeping a game on its loading screen\) while it waits for shaders to compile\.<br>This will mean for instance a game's menu may be active but not be able to render until the compilation is complete, rather than blocking on the loading screen and transitioning to the menu only once all shaders are loaded\. Not blocking the application is typically better for user experience regardless though as long as some sort of progress UI is displayed to indicate what is happening\.|
|rtx.shader.enableAsyncCompilationUI|bool|True|Enables a UI message when async shader compilation is in progress to indicate the current compilation progress\. Only takes effect when rtx\.shader\.enableAsyncCompilation is true\.<br>This should usually be enabled as providing information to the user about the current progress of compilation is useful\. May be disabled however for automated testing purposes if the nondeterministic behavior of the UI's rendered text interferes with testing\.|
|rtx.shader.prewarmAllVariants|bool|False|When set to true, all variants of shaders will be prewarmed at launch\. Only takes effect when rtx\.initializer\.asyncShaderPrewarming is set to true\.<br>By default Remix only prewarms shaders which may actually be used at runtime or are accessible by user\-facing graphics menus rather than all shader variants accessible by changing options in the developer menu\.<br>This has the benefit of minimizing shader compilation cost for typical users, but may cause shader compilation stalls when changing various options in the developer menu\. As such, this option is useful to enable during development to minimize these stalls\.<br>Do note however that enabling this option will have a significant performance impact whenever shaders are uncached \(e\.g\. on first load\) due to requiring many more shaders to be compiled\. As such using the enviornment variable to set this option locally on a developer's machine is recommended over a configuration file change to ensure it is not accidently enabled for users\.|
|rtx.shader.recompileOnLaunch|bool|False|When set to true runtime shader recompilation will execute on the first frame after launch\.<br>This option is mainly meant for development use and should not be set for user\-facing operation\. Also see rtx\.useLiveShaderEditMode for a similar option which auto\-detects shader changes instead\.|
|rtx.shader.useLiveEditMode|bool|False|When set to true shaders will be automatically recompiled when any shader file is updated \(saved for instance\) in addition to the usual manual recompilation trigger\.<br>This option is mainly meant for development use and should not be set for user\-facing operation\.|
|rtx.shakeCamera|bool|False|Enables animation of the free camera\.|
|rtx.showLegacyACESOption|bool|False|Show 'rtx\.useLegacyACES' in the developer menu\. Default is OFF, as the non\-legacy ACES is currently experimental and the implementation is a subject to change\.|
|rtx.showRayReconstructionUI|bool|True|Show ray reconstruction UI\.|
|rtx.showRaytracingOption|bool|True|Enables or disables the option to toggle ray tracing in the UI\. When set to false the ray tracing checkbox will not appear in the Remix UI\.|
|rtx.showUI|int|0|0 = Don't Show, 1 = Show Simple, 2 = Show Advanced\.|
|rtx.showUICursor|bool|True||
|rtx.skipDrawCallsPostRTXInjection|bool|False|Ignores all draw calls recorded after RTX Injection, the location of which varies but is currently based on when tagged UI textures begin to draw\.|
|rtx.skipObjectsWithUnknownCamera|bool|False||
|rtx.skyAutoDetect|int|0|Automatically tag sky draw calls using various heuristics\.<br>0 = None<br>1 = CameraPosition \- assume the first seen camera position is a sky camera\.<br>2 = CameraPositionAndDepthFlags \- assume the first seen camera position is a sky camera, if its draw call's depth test is disabled\. If it's enabled, assume no sky camera\.<br>Note: if all draw calls are marked as sky, then assume that there's no sky camera at all\.|
|rtx.skyAutoDetectUniqueCameraDistance|float|1|If multiple cameras are found, this threshold distance \(in game units\) is used to distinguish a sky camera from a main camera\. Active if sky auto\-detect is set to CameraPosition / CameraPositionAndDepthFlags\.|
|rtx.skyBrightness|float|1||
|rtx.skyDrawcallIdThreshold|int|0|It's common in games to render the skybox first, and so, this value provides a simple mechanism to identify those early draw calls that are untextured \(textured draw calls can still use the Sky Textures functionality\.|
|rtx.skyForceHDR|bool|False|By default sky will be rasterized in the color format used by the game\. Set the checkbox to force sky to be rasterized in HDR intermediate format\. This may be important when sky textures replaced with HDR textures\.|
|rtx.skyMinZThreshold|float|1|If a draw call's viewport has min depth greater than or equal to this threshold, then assume that it's a sky\.|
|rtx.skyProbeSide|int|1024|Resolution of the skybox for indirect illumination \(rough reflections, global illumination etc\)\.|
|rtx.skyReprojectScale|float|16|Scaling of the sky geometry on reprojection to main camera space\.|
|rtx.skyReprojectToMainCameraSpace|bool|False|Move sky geometry to the main camera space\.<br>Useful, if a game has a skybox that contains geometry that can be a part of the main scene \(e\.g\. buildings, mountains\)\. So with this option enabled, that geometry would be promoted from sky rasterization to ray tracing\.|
|rtx.skyUiDrawcallCount|int|0||
|rtx.splashMessageDisplayTimeSeconds|int|20|The amount of time in seconds to display the Remix splash message for\.|
|rtx.stochasticAlphaBlendDepthDifference|float|0.1|Max depth difference for a valid neighbor\.|
|rtx.stochasticAlphaBlendDiscardBlackPixel|bool|False|Discard black pixels\.|
|rtx.stochasticAlphaBlendEnableFilter|bool|True|Filter samples to suppress noise\.|
|rtx.stochasticAlphaBlendInitialSearchRadius|float|10|Initial search radius\.|
|rtx.stochasticAlphaBlendNormalSimilarity|float|0.9|Min normal similarity for a valid neighbor\.|
|rtx.stochasticAlphaBlendOpacityThreshold|float|0.95|Max opacity to use stochastic alpha blend\.|
|rtx.stochasticAlphaBlendPlanarDifference|float|0.2|Max planar difference for a valid neighbor\.|
|rtx.stochasticAlphaBlendRadianceVolumeMultiplier|float|1|Radiance volume multiplier\.|
|rtx.stochasticAlphaBlendRadiusExpandFactor|float|1.6|Multiply radius by this factor if cannot find a good neighbor\.|
|rtx.stochasticAlphaBlendSearchIteration|int|6|Search iterations\.|
|rtx.stochasticAlphaBlendSearchTheSameObject|bool|True|Only use radiance samples from the same object\.|
|rtx.stochasticAlphaBlendShareNeighbors|bool|True|Share result with other pixels to accelerate search\.|
|rtx.stochasticAlphaBlendUseNeighborSearch|bool|True|Get radiance from neighbor opaque pixels\.|
|rtx.stochasticAlphaBlendUseRadianceVolume|bool|True|Get radiance from radiance volume\.|
|rtx.subsurface.diffusionProfileDebugPixelPosition|int2|2147483647, 2147483647|Pixel position where we show debugging sampling positions for diffusion profile\. Requires set debug view to 'SSS Diffusion Profile Sampling'\.|
|rtx.subsurface.diffusionProfileScale|float|1|Scalar of the diffusion profile scale\.|
|rtx.subsurface.enableDiffusionProfile|bool|True|Enable subsurface material\. Solve subsurface rendering equation with \(burley/SOTO\) diffusion profile\.|
|rtx.subsurface.enableTextureMaps|bool|True|Enable texture maps such as thickness map or scattering albedo map\. The corresponding subsurface properties will fallback to per\-material constants if this is disabled\.|
|rtx.subsurface.enableThinOpaque|bool|True|Enable thin opaque material\. The materials withthin opaque properties will fallback to normal opaque material\.|
|rtx.subsurface.enableTransmission|bool|True|Enable subsurface transmission\. Implement single scattering transmission for thin or curved SSS surface\.|
|rtx.subsurface.enableTransmissionDiffusionProfileCorrection|bool|False|Enable diffusion profile correction when enabling SSS Transmission\.<br>Both burley's diffusion profile and SSS Transmission includes the single scattering energy\.<br>The correction removes the single scattering part from diffusion profile to avoid double counting the single scattering energy\.|
|rtx.subsurface.enableTransmissionSingleScattering|bool|True|Enable single scattering for subsurface transmission\. If this option is disabled, then the refracted ray will not be scattered again inside of the volume\.|
|rtx.subsurface.surfaceThicknessScale|float|1|Scalar of the subsurface thickness\.|
|rtx.subsurface.transmissionBsdfSampleCount|int|1|The sample count for transmission BSDF\.\(1spp as default\)|
|rtx.subsurface.transmissionSingleScatteringSampleCount|int|1|The sample count for every single scattering on BSDF transmission \(refracted\) ray\.\(1spp as default\)|
|rtx.suppressLightKeeping|bool|False|If true, Remix doesn't keep game's original light sources for many frames\. For example, if a game switches a point light off, then, in Remix, the light might still be rendered as if it's enabled: because the light would be cached \(kept\) for many consecutive frames\. \(So to solve this, set this option to True\)\.|
|rtx.taauPreset|int|2|Adjusts TAA\-U scaling factor, trades quality for performance\.|
|rtx.temporalAA.colorClampingFactor|float|1|A scalar factor to apply to the standard deviation of the neighborhood of pixels in the color signal used for clamping\. Should be in the range 0\-infinity\.<br>This value essentially represents how many standard deviations of tolerance from the current frame's colors around each pixel pixel the temporally accumulated color signal may have\.<br>Higher values will cause more ghosting whereas lower values may reduce ghosting but will impact image quality \(less ability to upscale effectively\) and reduce stability \(more jittering\)\.|
|rtx.temporalAA.maximumRadiance|float|10000|The maximum value to use in TAA\-U's perceptual quantizer color transformation, measured in cd/m^2\.<br>The typical value used for the PQ transformation is 10,000 and usually shouldn't be changed\.|
|rtx.temporalAA.newFrameWeight|float|0.1|The maximum amount of the current frame to use as part of the temporal anti\-aliasing process\. Must be in the range 0\-1\.<br>Values closer to 0 will result in better image stability \(less jittering\) and less aliasing, values closer to 1 will result in more responsive results \(less ghosting\)\.|
|rtx.terrain.terrainAsDecalsAllowOverModulate|bool|False|Set to true, if it's known that terrain layers with ModulateX2 / ModulateX4 flags do not contain a lighting info, but ModulateX2 / ModulateX4 are used only to blend layers\.|
|rtx.terrain.terrainAsDecalsEnabledIfNoBaker|bool|False|If terrain baker is disabled, attempt to blend with the decals\.|
|rtx.terrainBaker.cascadeMap.defaultHalfWidth|float|1000|Cascade map square's default half width around the camera \[meters\]\. Used when the terrain's BBOX couldn't be estimated\.|
|rtx.terrainBaker.cascadeMap.defaultHeight|float|1000|Cascade map baker's camera default height above the in\-game camera \[meters\]\. Used when the terrain's BBOX couldn't be estimated\.|
|rtx.terrainBaker.cascadeMap.expandLastCascade|bool|True|Expands the last cascade's footprint to cover the whole cascade map\.<br>This ensures whole terrain surface has valid baked texture data to sample from<br>even if there isn't enough cascades generated \(due to the current settings or limitations\)\.|
|rtx.terrainBaker.cascadeMap.levelHalfWidth|float|10|First cascade level square's half width around the camera \[meters\]\.|
|rtx.terrainBaker.cascadeMap.levelResolution|int|4096|Texture resolution per cascade level\.|
|rtx.terrainBaker.cascadeMap.maxLevels|int|8|Max number of cascade levels\.|
|rtx.terrainBaker.cascadeMap.useTerrainBBOX|bool|True|Uses terrain's bounding box to calculate the cascade map's scene footprint\.|
|rtx.terrainBaker.clearTerrainBeforeBaking|bool|False|Performs a clear on the terrain texture before it is baked to in a frame\.|
|rtx.terrainBaker.debugDisableBaking|bool|False|Force disables rebaking every frame\. Used for debugging only\.|
|rtx.terrainBaker.debugDisableBinding|bool|False|Force disables binding of the baked terrain texture to the terrain meshes\. Used for debugging only\.|
|rtx.terrainBaker.enableBaking|bool|True|\[Experimental\] Enables runtime baking of blended terrains from top down \(i\.e\. in an opposite direction of "rtx\.zUp"\)\.<br>It bakes multiple blended albedo terrain textures into a single texture sampled during ray tracing\. The system requires "Terrain Textures" to contain hashes of the terrain textures to apply\.<br>Only use this system if the game renders terrain surfaces with multiple blended surfaces on top of each other \(i\.e\. sand mixed with dirt, grass, snow, etc\.\)\.<br>Requirement: the baked terrain surfaces must not be placed vertically in the game world\. Horizontal surfaces will have the best image quality\. Requires "rtx\.zUp" to be set properly\.|
|rtx.terrainBaker.material.bakeReplacementMaterials|bool|True|Enables baking of replacement materials when they are present\.|
|rtx.terrainBaker.material.bakeSecondaryPBRTextures|bool|True|Enables baking of secondary textures in replacement materials when they are present\.<br>Secondary textures are all PBR textures except for albedoOpacity\. So that includes normal, roughness, etc\.|
|rtx.terrainBaker.material.maxResolutionToUseForReplacementMaterials|int|8192|Max resolution to use for preprocessing and baking of input replacement material textures other than color opacity which is used as is\.<br>Applies only to a case when a preprocessing compute shader is used to support baking of secondary PBR materials\.<br>Replacement materials need to be preprocessed prior to baking them and limitting the max resolution allows to balance the quality vs performance cost\.|
|rtx.terrainBaker.material.properties.displaceInFactor|float|1|The max depth and height the baked terrain can support will be larger than the max <br>of any incoming draw call, which results in a loss of detail\. When this is <br>too low, the displacement will lack detail\. When it is too high, the lowest <br>and highest parts of the POM will flatten out\.  This affects both displaceIn <br>and displaceOut, despite the name\.|
|rtx.terrainBaker.material.properties.emissiveColorConstant|float3|0, 0, 0|Emissive color constant\. Should be a color in sRGB colorspace with gamma encoding\.|
|rtx.terrainBaker.material.properties.emissiveIntensity|float|0|Emissive intensity\.|
|rtx.terrainBaker.material.properties.enableEmission|bool|False|A flag to determine if emission is enabled\.|
|rtx.terrainBaker.material.properties.metallicConstant|float|0.1|Metallic constant\. Valid range is \<0, 1\>\.|
|rtx.terrainBaker.material.properties.roughnessAnisotropy|float|0|Roughness anisotropy\. Valid range is \<\-1, 1\>, where 0 is isotropic\.|
|rtx.terrainBaker.material.properties.roughnessConstant|float|0.7|Perceptual roughness constant\. Valid range is \<0, 1\>\.|
|rtx.terrainBaker.material.replacementSupportInPS|bool|True|Enables reading of secondary PBR replacement textures in pixel shaders when supported\.<br>Current support is limitted to fixed function pipelines and programmable shaders with Shader Model 1\.0\.<br>When set to false or unsupported, an extra compute shader is used to preproces the secondary textures to make them compatible at an expense of performance and quality instead\.<br>Requires "rtx\.terrainBaker\.material\.replacementSupportInPS\_fixedFunction = True" to apply for draw calls with fixed function graphics pipeline\.<br>Requires "rtx\.terrainBaker\.material\.replacementSupportInPS\_programmableShaders = True" to apply for draw calls with programmable graphics pipeline\.|
|rtx.terrainBaker.material.replacementSupportInPS_fixedFunction|bool|True|Enables reading of secondary PBR replacement textures in pixel shaders for games with fixed function graphics pipelines\.<br>When set to false, an extra compute shader is used to preproces the secondary textures to make them compatible at an expense of performance and quality instead\.<br>This parameter must be set at launch to apply\.|
|rtx.terrainBaker.material.replacementSupportInPS_programmableShaders|bool|True|\[Experimental\] Enables reading of secondary PBR replacement textures in pixel shaders for games with programmable graphics pipelines\."When set to false, an extra compute shader is used to preproces the secondary textures to make them compatible at an expense of performance and quality instead\.<br>This parameter must be set at launch to apply\. The current support for this is limitted to draw calls with programmable shaders with Shader Model 1\.0 only\.<br>Draw calls with Shader Model 2\.0\+ will use the preprocessing compute pass\.|
|rtx.texturemanager.budgetPercentageOfAvailableVram|int|50|The percentage of available VRAM we should use for material textures\.  If material textures are required beyond this budget, then those textures will be loaded at lower quality\.  Important note, it's impossible to perfectly match the budget while maintaining reasonable quality levels, so use this as more of a guideline\.  If the replacements assets are simply too large for the target GPUs available vid mem, we may end up going overbudget regularly\.  Defaults to 50% of the available VRAM\.|
|rtx.texturemanager.fixedBudgetEnable|bool|False|If true, rtx\.texturemanager\.fixedBudgetMiB is used instead of rtx\.texturemanager\.budgetPercentageOfAvailableVram\.|
|rtx.texturemanager.fixedBudgetMiB|int|2048|Fixed\-size VRAM budget for replacement textures\. In mebibytes\. To use, set rtx\.texturemanager\.fixedBudgetEnable to True\.|
|rtx.texturemanager.neverDowngradeTextures|bool|False|Debug option to forcibly prevent uploading lower resolution data, if the texture already has been promoted to a high resolution\.|
|rtx.texturemanager.samplerFeedbackEnable|bool|True|Enable texture sampler feedback\. If true, a texture prioritization logic considers the amount of mip\-levels that was sampled by a GPU while rendering a scene\.\(For example, if a texture is in the distance, it will have a lower priority compared to a texture rendered just in front of the camera\)\.|
|rtx.texturemanager.showProgress|bool|False|Show texture loading progress in the HUD\.|
|rtx.texturemanager.stagingBufferSizeMiB|int|96|Size of a pre\-allocated staging \(intermediate\) buffer to use when sending a texture from a RAM to GPU VRAM\. If a texture size exceeds this limit, it will not be considered for the texture streaming\. In mebibytes\.|
|rtx.timeDeltaBetweenFrames|float|0|Frame time delta in milliseconds to use for rendering\.<br>Setting this to 0 will use actual frame time delta for a given frame\. Non\-zero value allows the actual time delta to be overridden and is primarily used for automation to ensure determinism run to run without variance due to frame time fluctuations\.|
|rtx.tonemap.colorBalance|float3|1, 1, 1|The color tint to apply after tonemapping when color grading is enabled for the tonemapper \(rtx\.tonemap\.colorGradingEnabled\)\. Values should be in the range \[0, 1\]\.|
|rtx.tonemap.colorGradingEnabled|bool|False|A flag to enable or disable color grading after the global tonemapper's tonemapping pass, but before gamma correction and dithering \(if enabled\)\.|
|rtx.tonemap.contrast|float|1|The contrast adjustment to apply after tonemapping when color grading is enabled for the tonemapper \(rtx\.tonemap\.colorGradingEnabled\)\. Values should be in the range \[0, 1\]\.|
|rtx.tonemap.curveShift|float|0|Range \[0, inf\)\. Amount by which to shift the tone curve up or down\. Nonzero values will cause additional clipping\.|
|rtx.tonemap.ditherMode|int|2|Tonemap dither mode selection, dithering allows for reduction of banding artifacts in the final rendered output from quantization using a small amount of monochromatic noise\. Impact typically most visible in darker regions with smooth lighting gradients\.<br>Enabling dithering will make the rendered image slightly noisier, though usually dither noise is fairly imperceptible in most cases without looking closely\. Generally dithered results will also look better than the alternative of banding artifacts due to increasing perceptual precision of the signal\.<br>Note that temporal dithering may increase perceptual precision further but may also introduce more noticeable noise in the final output in some cases due to the noise pattern changing every frame unlike a purely spatial approach\.<br>Supported enum values are 0 = None \(Disabled\), 1 = Spatial \(Enabled, Spatial dithering only\), 2 = SpatialTemporal \(Enabled, Spatial and temporal dithering\)\.<br>Generally enabling dithering is recommended, but disabling it may be useful in some niche cases for improving compression ratios in images or videos at the cost of quality \(as noise while it may not be very visible may be more difficult to compress\), or for capturing "raw" post\-tonemapped data from the renderer\.|
|rtx.tonemap.dynamicRange|float|15|Range \[0, inf\)\. Without further adjustments, the tone curve will try to fit the entire luminance of the scene into the range \[\-dynamicRange, 0\] in linear photographic stops\. Higher values adjust for ambient monitor lighting; perfect conditions \-\> 17\.587 stops\.|
|rtx.tonemap.exposureBias|float|0|The exposure value to use for the global tonemapper when auto exposure is disabled, or a bias multiplier on top of the auto exposure's calculated exposure value\.|
|rtx.tonemap.finalizeWithACES|bool|False|A flag to enable applying a final pass of ACES tonemapping to the tonemapped result\.|
|rtx.tonemap.maxExposureIncrease|float|5|Range \[0, inf\)\. Forces the tone curve to not increase luminance values at any point more than this value\.|
|rtx.tonemap.saturation|float|1|The saturation adjustment to apply after tonemapping when color grading is enabled for the tonemapper \(rtx\.tonemap\.colorGradingEnabled\)\. Values should be in the range \[0, 1\]\.|
|rtx.tonemap.shadowContrast|float|0|Range \[0, inf\)\. Additional gamma power to apply to the tone of the tone curve below shadowContrastEnd\.|
|rtx.tonemap.shadowContrastEnd|float|0|Range \(\-inf, 0\]\. High endpoint for the shadow contrast effect in linear stops; values above this are unaffected\.|
|rtx.tonemap.shadowMinSlope|float|0|Range \[0, inf\)\. Forces the tone curve below a linear value of 0\.18 to have at least this slope, making the tone darker\.|
|rtx.tonemap.toneCurveMaxStops|float|8|High endpoint of the tone curve \(in log2\(linear\)\)\.|
|rtx.tonemap.toneCurveMinStops|float|-24|Low endpoint of the tone curve \(in log2\(linear\)\)\.|
|rtx.tonemap.tonemappingEnabled|bool|True|A flag to enable or disable the local tonemapper\. Note this flag will only take effect when the global tonemapper is set to be used \(as opposed to another option such as the local tonemapper\)\.|
|rtx.tonemap.tuningMode|bool|False|A flag to enable a debug visualization to tune the tonemapping exposure curve with, as well as exposing parameters for tuning the tonemapping in the UI\.|
|rtx.tonemappingMode|int|1|The tonemapping type to use, 0 for Global, 1 for Local \(Default\)\.<br>Global tonemapping tonemaps the image with respect to global parameters, usually based on statistics about the rendered image as a whole\.<br>Local tonemapping on the other hand uses more spatially\-local parameters determined by regions of the rendered image rather than the whole image\.<br>Local tonemapping can result in better preservation of highlights and shadows in scenes with high amounts of dynamic range whereas global tonemapping may have to comprimise between over or underexposure\.|
|rtx.trackParticleObjects|bool|True|Track last frame's corresponding particle object\.|
|rtx.translucentDecalAlbedoFactor|float|10|A global scale factor applied to the albedo of decals that are applied to a translucent base material, to make the decals more visible\.<br>This is generally needed as albedo values for decals may be fairly low when dealing with opaque surfaces, but the translucent diffuse layer requires a fairly high albedo value to result in an expected look\.<br>The need for this option could be avoided by simply authoring decals applied to translucent materials with a higher albedo to begin with, but sometimes applications may share decals between different material types\.|
|rtx.translucentMaterial.animatedWaterEnable|bool|True|If enabled, draw calls in the AnimatedWater category and a translucent material will have their primary texcoordinates animated, and will also take a second sample from the normal map\.<br>Note that objects must be properly categorized as animated water to be rendered with this mode\.|
|rtx.translucentMaterial.animatedWaterPrimaryNormalMotion|float2|0.05, 0.05|Velocity in UV space for the primary texture coordinate\.<br>This relies on Remix animation time, which will not respect any time warping performed by the game \(so pause, slow mo, etc will not change animation speed\)\.|
|rtx.translucentMaterial.animatedWaterSecondaryNormalLodBias|float|1|LoD bias to use when taking the second normal map sample\.<br>Values greater than 0 will cause the secondary normal map to be blurred, resulting in lower frequency waves\.|
|rtx.translucentMaterial.animatedWaterSecondaryNormalMotion|float2|-0.03, -0.06|Velocity in UV space for the secondary texture coordinate\.<br>This relies on Remix animation time, which will not respect any time warping performed by the game \(so pause, slow mo, etc will not change animation speed\)\.|
|rtx.translucentMaterial.enableDiffuseLayerOverride|bool|False|A flag to force the diffuse layer on the translucent material to be enabled\. Should only be used for debugging or development\.|
|rtx.translucentMaterial.normalIntensity|float|1|An arbitrary strength scale factor to apply when decoding normals in the translucent material\. Should only be used for debugging or development\.|
|rtx.translucentMaterial.transmittanceColorBias|float|0|A bias factor to add to all transmittance color values in the opaque material\. Should only be used for debugging or development\.|
|rtx.translucentMaterial.transmittanceColorScale|float|1|A scale factor to apply to all transmittance color values in the translucent material\. Should only be used for debugging or development\.|
|rtx.translucentSpecularLobeSamplingProbabilityZeroThreshold|float|0.01|The threshold for which to zero translucent specular probability weight values\.|
|rtx.translucentTransmissionLobeSamplingProbabilityZeroThreshold|float|0.01|The threshold for which to zero translucent transmission probability weight values\.|
|rtx.uniqueObjectDistance|float|300|The distance \(in game units\) that an object can move in a single frame before it is no longer considered the same object\.<br>If this is too low, fast moving objects may flicker and have bad lighting\.  If it's too high, repeated objects may flicker\.<br>This does not account for sceneScale\.|
|rtx.upscalerType|int|1|Upscaling boosts performance with varying degrees of image quality tradeoff depending on the type of upscaler and the quality mode/preset\.|
|rtx.upscalingMipBias|float|0|Specifies a mipmapping level bias to add to all material texture filtering when upscaling \(such as DLSS\) is used\.<br>Mipmaps are determined based on how far away a texture is, using this can bias the desired level in a lower quality direction \(positive bias\), or a higher quality direction with potentially more aliasing \(negative bias\)\.<br>Note that mipmaps are also important for good spatial caching of textures, so too far negative of a mip bias may start to significantly affect performance, therefore changing this value is not recommended|
|rtx.useAnisotropicFiltering|bool|True|A flag to indicate if anisotropic filtering should be used on material textures, otherwise typical trilinear filtering will be used\.<br>This should generally be enabled as anisotropic filtering allows for less blurring on textures at grazing angles than typical trilinear filtering with only usually minor performance impact \(depending on the max anisotropy samples\)\.|
|rtx.useBuffersDirectly|bool|True|When enabled Remix will use the incoming vertex buffers directly where possible instead of copying data\. Note: setting the d3d9\.allowDiscard to False will disable this option\.|
|rtx.useDenoiser|bool|True|Enables usage of denoiser\(s\) when set to true, otherwise disables denoising when set to false\.<br>Denoising is important for filtering the raw noisy ray traced signal into a smoother and more stable result at the cost of some potential spatial/temporal artifacts \(ghosting, boiling, blurring, etc\)\.<br>Generally should remain enabled except when debugging behavior which requires investigating the output directly, or diagnosing denoising\-related issues\.|
|rtx.useDenoiserReferenceMode|bool|False|Enables reference "denoiser" \(~ accumulation mode\) when set to true, otherwise uses a standard denoiser\.<br>The reference denoiser accumulates frames over time to generate a reference multi\-sample per pixel contribution<br>which should converge slowly to the ideal result the renderer is working towards\.<br>It is useful for analyzing quality differences in various denoising methods, post\-processing filters,<br>or for more accurately comparing subtle effects of potentially biased rendering techniques<br>which may be hard to see through noise and filtering\.<br>It is also useful for higher quality artistic renders of a scene beyond what is possible in real\-time\.|
|rtx.useHighlightLegacyMode|bool|False||
|rtx.useHighlightUnsafeAnchorMode|bool|False||
|rtx.useHighlightUnsafeReplacementMode|bool|False||
|rtx.useIntersectionBillboardsOnPrimaryRays|bool|False||
|rtx.useLegacyACES|bool|True|Use a luminance\-only approximation of ACES that over\-saturates the highlights\. If false, use a refined ACES transform that converts between color spaces with more precision\.|
|rtx.useObsoleteHashOnTextureUpload|bool|False|Whether or not to use slower XXH64 hash on texture upload\.<br>New projects should not enable this option as this solely exists for compatibility with older hashing schemes\.|
|rtx.usePartialDdsLoader|bool|True|A flag controlling if the partial DDS loader should be used, true to enable, false to disable and use GLI instead\.<br>Generally this should be always enabled as it allows for simple parsing of DDS header information without loading the entire texture into memory like GLI does to retrieve similar information\.<br>Should only be set to false for debugging purposes if the partial DDS loader's logic is suspected to be incorrect to compare against GLI's implementation\.|
|rtx.usePostFilter|bool|True|Uses post filter to remove fireflies in the denoised result\.|
|rtx.useRTXDI|bool|True|A flag indicating if RTXDI should be used, true enables RTXDI, false disables it and falls back on simpler light sampling methods\.<br>RTXDI provides improved direct light sampling quality over traditional methods and should generally be enabled for improved direct lighting quality at the cost of some performance\.|
|rtx.useRayPortalVirtualInstanceMatching|bool|True||
|rtx.useVertexCapture|bool|True|When enabled, injects code into the original vertex shader to capture final shaded vertex positions\.  Is useful for games using simple vertex shaders, that still also set the fixed function transform matrices\.|
|rtx.useVertexCapturedNormals|bool|True|When enabled, vertex normals are read from the input assembler and used in raytracing\.  This doesn't always work as normals can be in any coordinate space, but can help sometimes\.|
|rtx.useVirtualShadingNormalsForDenoising|bool|True|A flag to enable or disable the usage of virtual shading normals for denoising passes\.<br>This is primairly important for anything that modifies the direction of a primary ray, so mainly PSR and ray portals as both of these will view a surface from an angle different from the "virtual" viewing direction perceived by the camera\.<br>This can cause some issues with denoising due to the normals not matching the expected perception of what the normals should be, for example normals facing away from the camera direction due to being viewed from a different angle via refraction or portal teleportation\.<br>To correct this, virtual normals are calculcated such that they always are oriented relative to the primary camera ray as if its direction was never altered, matching the virtual perception of the surface from the camera's point of view\.<br>As an aside, virtual normals themselves can cause issues with denoising due to the normals suddenly changing from virtual to "real" normals upon traveling through a portal, causing surface consistency failures in the denoiser, but this is accounted for via a special transform given to the denoiser on camera ray portal teleportation events\.<br>As such, this option should generally always be enabled when rendering with ray portals in the scene to have good denoising quality\.|
|rtx.useWhiteMaterialMode|bool|False|Override all objects' materials by white material|
|rtx.useWorldMatricesForShaders|bool|True|When enabled, Remix will utilize the world matrices being passed from the game via D3D9 fixed function API, even when running with shaders\.  Sometimes games pass these matrices and they are useful, however for some games they are very unreliable, and should be filtered out\.  If you're seeing precision related issues with shader vertex capture, try disabling this setting\.|
|rtx.userBrightness.userBrightness|int|50|How bright the final image should be\. \[0,100\] range\.|
|rtx.userBrightnessEVRange.userBrightnessEVRange|float|3|The exposure value \(EV\) range for 'rtx\.userBrightness' slider, i\.e\. how much of EV there is between 0 and 100 slider values\.|
|rtx.validateCPUIndexData|bool|False||
|rtx.vertexColorStrength|float|0.6|A scalar to apply to how strong vertex color influence should be on materials\.<br>A value of 1 indicates that it should be fully considered \(though do note the texture operation and relevant parameters still control how much it should be blended with the actual albedo color\), a value of 0 indicates that it should be fully ignored\.|
|rtx.viewDistance.distanceFadeMax|float|500|The view distance based on the result of the view distance function to end view distance noise fading at \(and effectively draw nothing past this point\), only used for the Coherent Noise view distance mode\.|
|rtx.viewDistance.distanceFadeMin|float|400|The view distance based on the result of the view distance function to start view distance noise fading at, only used for the Coherent Noise view distance mode\.|
|rtx.viewDistance.distanceFunction|int|0|The view distance function, Euclidean is a simple distance from the camera, whereas Planar Euclidean will ignore distance across the world's "up" direction\.|
|rtx.viewDistance.distanceMode|int|0|The view distance mode, None disables view distance, Hard Cutoff will cut off geometry past a point, and Coherent Noise will feather geometry out using a stable worldspace noise pattern \(experimental\)\.|
|rtx.viewDistance.distanceThreshold|float|500|The view distance to draw out to based on the result of the view distance function, only used for the Hard Cutoff view distance mode\.|
|rtx.viewDistance.noiseScale|float|3|The scale per meter value applied to ther world space position fed into the noise generation function for generating the fade in Coherent Noise view distance mode\.|
|rtx.viewModel.enable|bool|False|If true, try to resolve view models \(e\.g\. first\-person weapons\)\. World geometry doesn't have shadows / reflections / etc from the view models\.|
|rtx.viewModel.enableVirtualInstances|bool|True|If true, virtual instances are created to render the view models behind a portal\.|
|rtx.viewModel.maxZThreshold|float|0|If a draw call's viewport has max depth less than or equal to this threshold, then assume that it's a view model\.|
|rtx.viewModel.perspectiveCorrection|bool|True|If true, apply correction to view models \(e\.g\. different FOV is used for view models\)\.|
|rtx.viewModel.rangeMeters|float|1|\[meters\] Max distance at which to find a portal for view model virtual instances\. If rtx\.viewModel\.separateRays is true, this is also max length of view model rays\.|
|rtx.viewModel.scale|float|1|Scale for view models\. Minimize to prevent clipping\.|
|rtx.volumetrics.anisotropy|float|0|The anisotropy of the scattering phase function \(\-1 being backscattering, 0 being isotropic, 1 being forward scattering\)\.|
|rtx.volumetrics.atmosphereHeightMeters|float|30|Height of the atmosphere in meters, respects scene scale\.|
|rtx.volumetrics.atmosphereInverted|bool|False|A flag to invert the rendering of the volumetric atmosphere if rtx\.volumetrics\.enableAtmosphere is enabled\.<br>Some games render the world upside down and that cannot be detected automatically, this setting can be used to correct that inversion for the volumetric atmosphere\.|
|rtx.volumetrics.atmospherePlanetRadiusMeters|float|10000|Radius of the planet in meters, respects scene scale\.|
|rtx.volumetrics.debugDisableRadianceScaling|bool|False|Disables the volumetric radiance scaling feature, this effectively sets the per light radiance scaling to 1\.f\.  Useful when debugging issues when this feature is suspected\.<br>Do not ship your mod with this in the rtx\.conf\.|
|rtx.volumetrics.depthOffset|float|0.5|Depth offset to avoid volumetric light leaking\.|
|rtx.volumetrics.enable|bool|True|Enabling volumetric lighting provides higher quality ray traced physical volumetrics, disabling falls back to cheaper depth based fog\.<br>Note that disabling this option does not disable the froxel radiance cache as a whole as it is still needed for other non\-volumetric lighting approximations\.|
|rtx.volumetrics.enableAtmosphere|bool|False|Enables a finite atmosphere in the volumetrics system\.<br>When false, the volumetric volume is assumed to reach to infinity in every direction, when true the volumetric volume will be limited to that a finite atmosphere controlled by parameters describing atmosphere height and its curvature via a planetary radius\.<br>This option should generally be enabled if volumetrics are used in outdoor settings as without a finite atmosphere infinite light sources such as the skybox and distant lights will not function properly\.|
|rtx.volumetrics.enableFogColorRemap|bool|False|A flag to enable or disable remapping fixed function fox's color\. Only takes effect when fog remapping in general is enabled\.<br>Enables or disables remapping functionality relating to the color parameter of fixed function fog with the exception of the multiscattering scale \(as this scale can be set to 0 to disable it\)\.<br>This allows dynamic changes to the game's fog color to be reflected somewhat in the volumetrics system\. Overrides the specified volumetric transmittance color\.|
|rtx.volumetrics.enableFogMaxDistanceRemap|bool|True|A flag to enable or disable remapping fixed function fox's max distance\. Only takes effect when fog remapping in general is enabled\.<br>Enables or disables remapping functionality relating to the max distance parameter of fixed function fog\.<br>This allows dynamic changes to the game's fog max distance to be reflected somewhat in the volumetrics system\. Overrides the specified volumetric transmittance measurement distance\.|
|rtx.volumetrics.enableFogRemap|bool|False|A flag to enable or disable fixed function fog remapping\. Only takes effect when volumetrics are enabled\.<br>Typically many old games used fixed function fog for various effects and while sometimes this fog can be replaced with proper volumetrics globally, other times require some amount of dynamic behavior controlled by the game\.<br>When enabled this option allows for remapping of fixed function fog parameters from the game to volumetric parameters to accomodate this dynamic need\.|
|rtx.volumetrics.enableHeterogeneousFog|bool|False|Enables a noise\-driven heterogeneous fog approximation\.|
|rtx.volumetrics.enableInPortals|bool|False|Enables using extra frustum\-aligned volumes for lighting in portals\.<br>Note that enabling this option will require 3x the memory of the typical froxel grid as well as degrade performance in some cases\.<br>This option should be enabled always in games using ray portals for proper looking volumetrics through them, but should be disabled on any game not using ray portals\.<br>Additionally, this setting must be set at startup and changing it will not take effect at runtime\.|
|rtx.volumetrics.enableInitialVisibility|bool|True|Determines whether to trace a visibility ray for Reservoir samples\.<br>Results in slightly less noise with the volumetric froxel grid light samples at the cost of a ray per froxel cell each frame and should generally be enabled\.|
|rtx.volumetrics.enableReferenceMode|bool|False|Enables reference mode for volumetrics\.  This is very expensive, but allows for rendering engineers to test how close sampling approximations are to the real thing\. This will not save\.|
|rtx.volumetrics.enableSpatialResampling|bool|True|Indicates if spatial resampling should be used for volume integration\.<br>Spatial resampling allows for reuse of spatial information when picking froxel grid light samples similar to how ReSTIR works, providing higher quality light samples\.<br>|
|rtx.volumetrics.enableTemporalResampling|bool|True|Indicates if temporal resampling should be used for volume integration\.<br>Temporal resampling allows for reuse of temporal information when picking froxel grid light samples similar to how ReSTIR works, providing higher quality light samples\.<br>This should generally be enabled but currently due to the lack of temporal bias correction this option will slightly bias the lighting result\.|
|rtx.volumetrics.fogRemapColorMultiscatteringScale|float|0.1|A value representing the scale of the fixed function fog's color in the multiscattering approximation\.<br>This scaling factor is applied to the fixed function fog's color and becomes a multiscattering approximation in the volumetrics system\.<br>Sometimes useful but this multiscattering approximation is very basic \(just a simple ambient term for now essentially\) and may not look very good depending on various conditions\.|
|rtx.volumetrics.fogRemapMaxDistanceMaxMeters|float|40|A value controlling the "max distance" fixed function fog parameter's maximum remapping bound\.<br>Note that fog remapping and fog max distance remapping must be enabled for this setting to have any effect\.  In meters\.|
|rtx.volumetrics.fogRemapMaxDistanceMinMeters|float|1|A value controlling the "max distance" fixed function fog parameter's minimum remapping bound\.<br>Note that fog remapping and fog max distance remapping must be enabled for this setting to have any effect\.  In meters\.|
|rtx.volumetrics.fogRemapTransmittanceMeasurementDistanceMaxMeters|float|100|A value representing the transmittance measurement distance's maximum remapping bound\.<br>When the fixed function fog's "max distance" parameter is at or above its specified maximum the volumetric system's transmittance measurement distance will be set to this value and interpolated upwards\.<br>Note that fog remapping and fog max distance remapping must be enabled for this setting to have any effect\.  In meters\.|
|rtx.volumetrics.fogRemapTransmittanceMeasurementDistanceMinMeters|float|20|A value representing the transmittance measurement distance's minimum remapping bound\.<br>When the fixed function fog's "max distance" parameter is at or below its specified minimum the volumetric system's transmittance measurement distance will be set to this value and interpolated upwards\.<br>Note that fog remapping and fog max distance remapping must be enabled for this setting to have any effect\.  In meters\.|
|rtx.volumetrics.froxelDepthSliceDistributionExponent|float|2|The exponent to use on depth values to nonlinearly distribute froxels away from the camera\. Higher values bias more froxels closer to the camera with 1 being linear\.|
|rtx.volumetrics.froxelDepthSlices|int|64|The z dimension of the froxel grid\. Must be constant after initialization\.|
|rtx.volumetrics.froxelFireflyFilteringLuminanceThreshold|float|1000|Sets the maximum luminance threshold for the volumetric firefly filtering to clamp to\.|
|rtx.volumetrics.froxelGridResolutionScale|int|8|The scale factor to divide the x and y render resolution by to determine the x and y dimensions of the froxel grid\.|
|rtx.volumetrics.froxelMaxDistanceMeters|float|20|The maximum distance in world units to allocate the froxel grid out to\. Should be less than the distance between the camera's near and far plane, as the froxel grid will clip to the far plane otherwise\.  The unit of measurement is meters\.|
|rtx.volumetrics.initialRISSampleCount|int|32|The number of RIS samples to select from the global pool of lights when constructing a Reservoir sample\.<br>Higher values generally increases the quality of the selected light sample, though similar to the general RIS light sample count has diminishing returns\.|
|rtx.volumetrics.maxAccumulationFrames|int|128|The number of frames to accumulate volume lighting samples over, maximum of 254\.<br>Large values result in greater image stability at the cost of potentially more temporal lag\.Should generally be set to as large a value as is viable as the froxel radiance cache is assumed to be fairly noise\-free and stable which temporal accumulation helps with\.|
|rtx.volumetrics.noiseFieldDensityScale|float|1|A scale factor for the heterogeneous fog noise volume density\.|
|rtx.volumetrics.noiseFieldOctaves|int|4|Visual Parameter: Controls how much detail is in the heterogeneous fog noise volume\.  Detail will be fundamentally limited by the resolution of the froxel grid\.|
|rtx.volumetrics.noiseFieldSpatialFrequency|float|0.02|Visual Parameter: Frequency at which to sample the heterogeneous fog noise volume\.|
|rtx.volumetrics.noiseFieldSubStepSizeMeters|float|10|Maximum substep size in world space for sampling the heterogeneous fog noise volume\. Units are meters, respects scene scale\.|
|rtx.volumetrics.restirFroxelDepthSlices|int|128|The z dimension of the ReSTIR froxel grid\. Must be constant after initialization\.|
|rtx.volumetrics.restirGridGuardBandFactor|float|1.1|The scale factor for the restir grid guard band, which is an extended part of the viewing frustum for which we should calculate lighting information for, even though they are technically offscreen\.  This helps reduce noise in cases where the camera is moving around\.|
|rtx.volumetrics.restirGridScale|int|4|The scale factor to divide the x and y froxel grid resolution by to determine the x and y dimensions of the ReSTIR froxel grid\.<br>Note that unlike the rtx\.volumetrics\.froxelGridResolutionScale option this is not dividing the render resolution, but rather is a scalar on top of the resulting froxel grid resolution after it is divided by the resolution scale\.|
|rtx.volumetrics.singleScatteringAlbedo|float3|0.999, 0.999, 0.999|The single scattering albedo \(otherwise known as the particle albedo\) representing the ratio of scattering to absorption\.<br>While color\-like in many ways this value is assumed to be more of a mathematical albedo \(unlike material albedo which is treated more as a color\), and is therefore treated as linearly encoded data \(not gamma\)\.|
|rtx.volumetrics.spatialReuseMaxSampleCount|int|8|The number of spatial samples to perform, generally higher is better, but the law of diminishing returns applies\.|
|rtx.volumetrics.spatialReuseSamplingRadius|float|0.8|Search radius \(in froxels\) to search for neighbour candidates in spatial reuse pass\.|
|rtx.volumetrics.temporalReuseMaxSampleCount|int|2|The number of samples to clamp temporal reservoirs to, should usually be around the value: desired\_max\_history\_frames \* average\_reservoir\_samples\.|
|rtx.volumetrics.transmittanceColor|float3|0.999, 0.999, 0.999|The color to use for calculating transmittance measured at a specific distance\.<br>Note that this color is assumed to be in sRGB space and gamma encoded as it will be converted to linear for use in volumetrics\.|
|rtx.volumetrics.transmittanceMeasurementDistanceMeters|float|200|The distance the specified transmittance color was measured at\. Lower distances indicate a denser medium\.  The unit of measurement is meters, respects scene scale\.|
|rtx.volumetrics.visibilityReuse|bool|True|Determines whether to reuse visibility ray samples spatially across the reservoir\.<br>Results in slightly less noise with the volumetric froxel grid light samples at the cost of a ray per froxel cell each frame and should generally be enabled\.|
|rtx.worldSpaceUiBackgroundOffset|float|-0.01|Distance along normal to offset objects rendered as worldspace UI, specifically for the background of screens\.|
|rtx.zUp|bool|False|Indicates that the Z axis is the "upward" axis in the world when true, otherwise the Y axis when false\.|

## Complex Types
| RTX Option | Type | Default Value | Description |
| :-- | :-: | :-: | :-- |
|rtx.animatedWaterTextures|hash set||Textures on draw calls to be treated as "animated water"\.<br>Objects with this flag applied will animate their normals to fake a basic water effect based on the layered water material parameters, and only when rtx\.opaqueMaterial\.layeredWaterNormalEnable is set to true\.<br>Should typically be used on static water planes that the original application may have relied on shaders to animate water on\.|
|rtx.antiCulling.antiCullingTextures|hash set||Textures that are forced to extend life length when anti\-culling is enabled\.<br>Some games use different culling methods we can't fully match, use this option to manually add textures to force extend their life when anti\-culling fails\.|
|rtx.baseGameModPathRegex|string||Regex used to redirect RTX Remix Runtime to another path for replacements and rtx\.conf\.|
|rtx.baseGameModRegex|string||Regex used to determine if the base game is running a mod, like a sourcemod\.|
|rtx.beamTextures|hash set||Textures on draw calls that are already particles or emissively blended and have beam\-like geometry\.<br>Typically objects marked as particles or objects using emissive blending will be rendered with a special method which allows re\-orientation of the billboard geometry assumed to make up the draw call in indirect rays \(reflections for example\)\.<br>This method works fine for typical particles, but some \(e\.g\. a laser beam\) may not be well\-represented with the typical billboard assumption of simply needing to rotate around its centroid to face the view direction\.<br>To handle such cases a different beam mode is used to treat objects as more of a cylindrical beam and re\-orient around its main spanning axis, allowing for better rendering of these beam\-like effect objects\.|
|rtx.cameraSequence.filePath|string||File path\.|
|rtx.captureInstanceStageName|string|capture_{timestamp}.usd|Name of the 'instance' stage \(see: 'rtx\.captureInstances'\)|
|rtx.captureTimestampReplacement|string|{timestamp}|String that can be used for auto\-replacing current time stamp in instance stage name|
|rtx.decalTextures|hash set||Textures on draw calls used for static geometric decals or decals with complex topology\.<br>These materials will be blended over the materials underneath them when decal material blending is enabled\.<br>A small configurable offset is applied to each flat/co\-planar part of these decals to prevent coplanar geometric cases \(which poses problems for ray tracing\)\.|
|rtx.dynamicDecalTextures|hash set||Warning: This option is deprecated, please use rtx\.decalTextures instead\.<br>Textures on draw calls used for dynamically spawned geometric decals, such as bullet holes\.<br>These materials will be blended over the materials underneath them when decal material blending is enabled\.<br>A small configurable offset is applied to each quad part of these decals to prevent coplanar geometric cases \(which poses problems for ray tracing\)\.|
|rtx.geometryAssetHashRuleString|string|positions,indices,geometrydescriptor|Defines which hashes we need to include when sampling from replacements and doing USD capture\.|
|rtx.geometryGenerationHashRuleString|string|positions,indices,texcoords,geometrydescriptor,vertexlayout,vertexshader|Defines which asset hashes we need to generate via the geometry processing engine\.|
|rtx.hideInstanceTextures|hash set||Textures on draw calls that should be hidden from rendering, but not totally ignored\.<br>This is similar to rtx\.ignoreTextures but instead of completely ignoring such draw calls they are only hidden from rendering, allowing for the hidden objects to still appear in captures\.<br>As such, this is mostly only a development tool to hide objects during development until they are properly replaced, otherwise the objects should be ignored with rtx\.ignoreTextures instead for better performance\.|
|rtx.ignoreAlphaOnTextures|hash set||Textures for which to ignore the alpha channel of the legacy colormap\. Textures will be rendered fully opaque as a result\.|
|rtx.ignoreBakedLightingTextures|hash set||Textures for which to ignore two types of baked lighting, Texture Factors and Vertex Color\.<br><br>Texture Factor disablement:<br>Using this feature on selected textures will eliminate the texture factors\.<br>For instance, if a game bakes lighting information into the Texture Factor for particular textures, applying this option will remove them\.<br>This becomes useful when unexpected results occur due to the Texture Factor\.<br>Consider an example where the original texture contains red tints baked into the Texture Factor\. If a user replaces the texture, it will blend with the red tints, resulting in an undesirable reddish outcome\.<br>In such cases, users can employ this option to eliminate the unwanted tints from their replacement textures\.<br>Similarly, users can tag textures if shadows are baked into the Texture Factor, causing the replacing texture to appear darker than anticipated\.<br><br>Vertex Color disablement:<br>Using this feature on selected textures will eliminate the vertex colors\.<br><br>Note, enabling this setting will automatically disable multiple\-stage texture factor blendings for the selected textures\.<br>Only use this option when necessary, as the Texture Factor and Vertex Color can be used for simulating various texture effects, tagging a texture with this option will unexpectedly eliminate these effects\.|
|rtx.ignoreLights|hash set||Lights that should be ignored\.<br>Any matching light will be skipped and not added to be ray traced\.|
|rtx.ignoreTextures|hash set||Textures on draw calls that should be ignored\.<br>Any draw call using an ignore texture will be skipped and not ray traced, useful for removing undesirable rasterized effects or geometry not suitable for ray tracing\.|
|rtx.ignoreTransparencyLayerTextures|hash set||Textures on draw calls that should not be stored in the transparency layer, when DLSS\-RR is on\.<br>The transparency layer stores noise\-free transparent objects which bypasses DLSS\-RR denoising, but it has lower anti\-aliasing quality\.<br>Transparent objects that have aliasing/flickering issues, like laser beams, can be added to this list to achieve better anti\-aliasing quality\.|
|rtx.lightConverter|hash set|||
|rtx.lightmapTextures|hash set||Textures used for lightmapping \(baked static lighting on surfaces\) in older games\.<br>These textures will be ignored when attempting to determine the desired textures from a draw to use for ray tracing\.|
|rtx.neuralRadianceCache.cudaDllDepsDirectoryPath|string||Optional setting for specifying a custom directory path where the CUDA run\-time dll dependencies are located\.|
|rtx.nonOffsetDecalTextures|hash set||Warning: This option is deprecated, please use rtx\.decalTextures instead\.<br>Textures on draw calls used for geometric decals with arbitrary topology that are already offset from the base geometry\.<br>These materials will be blended over the materials underneath them when decal material blending is enabled\.<br>Unlike typical decals however these decals have no offset applied to them due assuming the offset is already being done by whatever is passing data to Remix\.|
|rtx.opacityMicromapIgnoreTextures|hash set||Textures to ignore when generating Opacity Micromaps\. This generally does not have to be set and is only useful for black listing problematic cases for Opacity Micromap usage\.|
|rtx.particleTextures|hash set||Textures on draw calls that should be treated as particles\.<br>When objects are marked as particles more approximate rendering methods are leveraged allowing for more effecient and typically better looking particle rendering\.<br>Generally any billboard\-like blended particle objects in the original application should be classified this way\.|
|rtx.playerModelBodyTextures|hash set|||
|rtx.playerModelTextures|hash set|||
|rtx.postfx.motionBlurMaskOutTextures|hash set||Disable motion blur for meshes with specific texture\.|
|rtx.rayPortalModelTextureHashes|hash vector||Texture hashes identifying ray portals\. Allowed number of hashes: \{0, 2\}\.|
|rtx.raytracedRenderTargetTextures|hash set||DescriptorHashes for Render Targets\. \(Screens that should display the output of another camera\)\.|
|rtx.singleOffsetDecalTextures|hash set||Warning: This option is deprecated, please use rtx\.decalTextures instead\.<br>Textures on draw calls used for geometric decals that don't inter\-overlap for a given texture hash\. Textures must be tagged as "Decal Texture" or "Dynamic Decal Texture" to apply\.<br>Applies a single shared offset to all the batched decal geometry rendered in a given draw call, rather than increasing offset per decal within the batch \(i\.e\. a quad in case of "Dynamic Decal Texture"\)\.<br>Note, the offset adds to the global offset among all decals drawn with different draw calls\.<br>The decal textures tagged this way must not inter\-overlap within a batch / single draw call since the same offset is applied to all of them\.<br>Applying a single offset is useful for stabilizing decal offsets when a game dynamically batches decals together\.<br>In addition, it makes the global decal offset index grow slower and thus it minimizes a chance of hitting the "rtx\.decals\.maxOffsetIndex limit"\.|
|rtx.skyBoxGeometries|hash set||Geometries from draw calls used for the sky or are otherwise intended to be very far away from the camera at all times \(no parallax\)\.<br>Any draw calls using a geometry hash in this list will be treated as sky and rendered as such in a manner different from typical geometry\.<br>The geometry hash being used for sky detection is based off of the asset hash rule, see: "rtx\.geometryAssetHashRuleString"\.|
|rtx.skyBoxTextures|hash set||Textures on draw calls used for the sky or are otherwise intended to be very far away from the camera at all times \(no parallax\)\.<br>Any draw calls using a texture in this list will be treated as sky and rendered as such in a manner different from typical geometry\.|
|rtx.terrainTextures|hash set||Albedo textures that are baked blended together to form a unified terrain texture used during ray tracing\.<br>Put albedo textures into this category if the game renders terrain as a blend of multiple textures\.|
|rtx.uiTextures|hash set||Textures on draw calls that should be treated as screenspace UI elements\.<br>All exclusively UI\-related textures should be classified this way and doing so allows the UI to be rasterized on top of the ray traced scene like usual\.<br>Note that currently the first UI texture encountered triggers RTX injection \(though this may change in the future as this does cause issues with games that draw UI mid\-frame\)\.|
|rtx.welcomeMessage|string||Display a message to the user on startup, leave empty if no message is to be displayed\.|
|rtx.worldSpaceUiBackgroundTextures|hash set||Hack/workaround option for dynamic world space UI textures with a coplanar background\.<br>Apply to backgrounds if the foreground material is a dynamic world texture rendered in UI that is unpredictable and rapidly changing\.<br>This offsets the background texture backwards\.|
|rtx.worldSpaceUiTextures|hash set||Textures on draw calls that should be treated as worldspace UI elements\.<br>Unlike typical UI textures this option is useful for improved rendering of UI elements which appear as part of the scene \(moving around in 3D space rather than as a screenspace element\)\.|
